---
title: "GRN"
output: html_notebook
---

# Preprocess

Target cell type

```{r}
tgtct =
  "hepato"
  # "stellate"
  # "endothelial"
  # "myelo"
  # "T_NK"
```

Beforehand,
load `mat` from `7_GeneScoreMatrix.Rmd` and rename to `matGene`.
Load `mat` from `8_MotifMatrix.Rmd` and rename to `matMotif`.

```{r}
identical(colnames(matGene), colnames(matMotif))
```

Since highly correlated genes/motifs could be problematic in downstream analysis,
unify those to a representative.

```{r}
mat = matGene[, which(matGene$Clusters4BTmyelo == tgtct)]
# mat = matMotif[, which(matMotif$Clusters4BTmyelo == tgtct)]

matcor = cor(t(assay(mat)), method = "spearman") # takes an hour for matGene

diag(matcor) = 0
quantile(rowMaxs(abs(matcor)), seq(0, 1, 0.01))
quantile(rowMaxs(abs(matcor)), seq(0.99, 1, 0.001))
matcor[abs(matcor) < 0.9] = 0

# Are there negative correlations?
min(matcor)
matcor = abs(matcor)

# omit unique genes/motifs
index = which(rowSums(matcor) > 0)
identical(index, which(colSums(matcor) > 0))
matcor = matcor[index, index]

library(igraph)
x = as.character()
for (j in 1:ncol(matcor)) {
  connected = matcor[, j]
  connected = connected[connected > 0]
  x = c(x,
        as.character(
          rbind(
            names(connected),
            colnames(matcor)[j])))
}
matcorgraph = graph(edges = x, directed = FALSE)
matcorgraphcomp = igraph::components(matcorgraph, mode = "weak")

redundant = list()
for (i in unique(matcorgraphcomp$membership)) {
  m = names(matcorgraphcomp$membership)[matcorgraphcomp$membership == i]
  m = names(sort(rowSums(matcor[m, ]), decreasing = TRUE))
  # the largest is kept (and stored as name), and the others are redundant
  x = list(m[-1])
  names(x) = m[1]
  redundant = c(redundant, x)
}

# non-redundant
index = which(! rownames(mat) %in% unlist(redundant))
matnr = mat[index, ]

redundantGene = redundant
matnrGene = matnr
rownames(matnrGene) = paste0("Gene.", rownames(matnrGene))
# redundantMotif = redundant
# matnrMotif = matnr
# rownames(matnrMotif) = paste0("Motif.", rownames(matnrMotif))

# saveRDS(redundantGene,  file = paste0("redundantGene.",  tgtct, ".rds"))
# saveRDS(matnrGene,      file = paste0("matnrGene.",      tgtct, ".rds"))
# saveRDS(redundantMotif, file = paste0("redundantMotif.", tgtct, ".rds"))
# saveRDS(matnrMotif,     file = paste0("matnrMotif.",     tgtct, ".rds"))
redundantGene  = readRDS(paste0("redundantGene.",  tgtct, ".rds"))
matnrGene      = readRDS(paste0("matnrGene.",      tgtct, ".rds"))
redundantMotif = readRDS(paste0("redundantMotif.", tgtct, ".rds"))
matnrMotif     = readRDS(paste0("matnrMotif.",     tgtct, ".rds"))
```

Inspect.

```{r}
ggplot(data = data.frame(
  x = assay(matnrGene)["Gene.Abcg1", ],
  y = assay(matnrMotif)["Motif.Stat5b", ],
  s = as.character(matnrGene$Sample)),
  aes(x, y)) +
  geom_point(size = 0.5) +
  facet_grid(cols = vars(s))
```

Filter differentially expressed genes/motifs.
Beforehand,
load `resultcompared` from `7_GeneScoreMatrix.Rmd` and rename to `resultcomparedGene`.
Load `resultcompared` from `8_MotifMatrix.Rmd` and rename to `resultcomparedMotif`.
For robustness, we impose abs(estimate) > log2(1.1), which is arbitrary (especially for Motif).

```{r}
x = resultcomparedGene %>%
  dplyr::filter(abs(estimate) > log2(1.1) & FDR < 0.01 & celltype == tgtct) %>%
  dplyr::distinct(genename) %>%
  dplyr::pull(genename)
matnrDEGene = matnrGene[which(rownames(matnrGene) %in% paste0("Gene.", x)), ]

x = resultcomparedMotif %>%
  dplyr::filter(abs(estimate) > log2(1.1) & FDR < 0.01 & celltype == tgtct) %>%
  dplyr::distinct(genename) %>%
  dplyr::pull(genename)
matnrDEMotif = matnrMotif[which(rownames(matnrMotif) %in% paste0("Motif.", x)), ]
```

# One motif-to-one gene analysis

## Correlation between motifs and genes

```{r}
corMG = cor(
  t(assay(matnrMotif)),
  t(assay(matnrGene)),
  method = "spearman")

cornulldistribution =
  sapply(
    1:100,
    function (i) {
      print(i)
      set.seed(i)
      corMGsim = cor(
        t(assay(matnrMotif))[sample(ncol(matnrMotif)), ],
        t(assay(matnrGene)),
        method = "spearman")
      sapply(0:1000, function (x) { sum(abs(corMGsim) > x/1000) })
    })
max(which(
  rowMeans(cornulldistribution) /
    sapply(0:1000, function (x) { sum(abs(corMG) > x/1000) }) >= 0.01)) / 1000
# FDR<0.01
# hepatocyte >=0.035
# T_NK       >=0.161 (all samples; qn) OLD
mean(sort(
  apply(
    cornulldistribution,
    2,
    function (x) { (max(which(x > 0)) - 1)/1000 }),
  decreasing = TRUE)[5:6])
# globalP=0.05
# hepatocyte 0.062
# T_NK       0.281  (all samples; qn) OLD

# Keep only FDR<0.01
corMGsig = corMG
corMGsig[abs(corMGsig) < 0.035] = 0
```

Filter differentially expressed genes/motifs.

```{r}
all(rownames(matnrDEMotif) %in% rownames(corMGsig))
all(rownames(matnrDEGene)  %in% colnames(corMGsig))
corMGsigsig = corMGsig
corMGsigsig = corMGsigsig[rownames(matnrDEMotif), ]
corMGsigsig = corMGsigsig[, rownames(matnrDEGene)]
plot(quantile(abs(corMGsigsig), seq(0, 1, 0.01)))
```

## SVD of corMGsigsig

For hepato, 7 components look significant.
Component 1 is characterized by Motif.Fos, Motif.Smarcc1, Motif.Bach1.
Other components are not evident.

```{r}
x = svd(corMGsigsig)
plot(x$d)
dataplot =
  as.data.frame(x$u); rownames(dataplot) = rownames(corMGsigsig)
  # as.data.frame(x$v); rownames(dataplot) = colnames(corMGsigsig)
ggplot(data = dataplot,
       aes(x = V1,
           y = V2)) +
  geom_point(size = 0.5)

tail(sort(as.matrix(dataplot)[, 1]), 20)
```

## Graph of corMGsigsig

```{r}
library(igraph)

x = as.character()
for (j in 1:ncol(corMGsigsig)) {
  connected = corMGsigsig[, j]
  connected = connected[abs(connected) > 0]
  if (length(connected) > 0) {
    connected = connected[head(order(abs(connected), decreasing = TRUE), 5)]
    x = c(x,
          as.character(
            rbind(
              names(connected),
              colnames(corMGsigsig)[j])
          ))
  }
}
corMGsigsiggraph = graph(edges = x, directed = TRUE)
corMGsigsiggraphcomp = igraph::components(corMGsigsiggraph, mode = "weak")
corMGsigsiggraphcomp$csize
head(sort(degree(corMGsigsiggraph), decreasing = TRUE))
```

## Detect mediator motifs by conditional analysis; diminished t-statistic

We are interested if the effect of condition (ie diet) on Gene j
is mediated by Motif i.
We want to detect the information flow (causality) "condition -> Motif i -> Gene j".
It doesn't matter whether there is bypass "condition -> Gene j".
We test if the association of Gene j with condition decreases
when conditioned by Motif i.

```{r}
x = matnrDEMotif
y = matnrDEGene
g = x$Sample
g[g %in% c("m154211", "m167108")] = "sp"
x$spdietcombined = g
```

Compute the regression
condition ~ (Motif i) + (Gene j),
and keep the t-statistic for (Gene j).
For a fixed j, which i yields diminished t-statistic?

```{r}
cl = makeCluster(20)
clusterExport(cl, "assay")
clusterExport(cl, "x")
clusterExport(cl, "y")
# TODO CCA with all conditions combined as y
statadjusted =
  do.call(
    rbind,
    lapply(
      c("m154207", "m167203", "m168101"),
      function (s) {
        print(s)
        cond = as.character(x$spdietcombined)
        cond[! cond %in% c(s, "sp")] = NA
        do.call(
          rbind,
          lapply(
            row.names(x),
            function (i) {
              print(i)
              do.call(
                rbind,
                # lapply(
                parLapply(cl = cl,
                  row.names(y),
                  function (j) {
                    a0 = lm(y ~ x,
                            data = list(
                              y = (cond != "sp"),
                              x = cbind(
                                t(assay(y)[j, , drop = FALSE]),
                                t(assay(x)[i, , drop = FALSE]))))
                    data.frame(
                      Motif = i,
                      Gene = j,
                      sample = s,
                      statadjusted = summary(a0)$coefficients[2, "t value"])
                  }))
            }))
      }))
# saveRDS(statadjusted, file = paste0("statadjusted.", tgtct, ".rds"))
statadjusted = readRDS(paste0("statadjusted.", tgtct, ".rds"))
```

Overlay statadjusted with corMGsigsig.
We discard motif-gene pairs where corMGsigsig = 0.

```{r}
s = "m154207"
s = "m167203"
s = "m168101"

library(dplyr)
clusterExport(cl, c("s", "corMGsigsig", "statadjusted",
                    "filter",
                    "select",
                    "slice_min",
                    "arrange",
                    "%>%"))
statadjustededges =
  # sapply(
  parSapply(cl = cl,
    colnames(corMGsigsig),
    function (tgtgene) {
      data =
        statadjusted %>%
        dplyr::filter(Gene == tgtgene) %>%
        dplyr::filter(sample == s) %>%
        dplyr::select(Motif, statadjusted)
      data$corMGsigsig = corMGsigsig[data$Motif, tgtgene]
      data$statadjustedpos =
        data$statadjusted *
        sign(median(data$statadjusted))
      statadjustedposlb =
        2.5 * quantile(data$statadjustedpos, 0.25) +
        (-1.5) * quantile(data$statadjustedpos, 0.75)
      dataupstreamMotif =
        data %>%
        dplyr::filter(statadjustedpos < statadjustedposlb) %>%
        dplyr::filter(statadjustedpos >= 0) %>%
        dplyr::filter(corMGsigsig > sqrt(0.5) * max(data$corMGsigsig) |
                        corMGsigsig < sqrt(0.5) * min(data$corMGsigsig)) %>%
        dplyr::slice_min(statadjustedpos, n = 10) %>%
        dplyr::arrange(statadjustedpos)
      x = rep(0, nrow(corMGsigsig))
      names(x) = row.names(corMGsigsig)
      if (nrow(dataupstreamMotif) > 0) {
        x[dataupstreamMotif$Motif] = 1
      }
      return(x)
    })

plot(log10(sort(rowSums(statadjustededges))))
plot(
  log10(rank(- rowSums(statadjustededges))),
  log10(rowSums(statadjustededges)))
head(sort(rowSums(statadjustededges), decreasing = TRUE), 20)
```

The motifs with higher degrees (ie hubs)
show larger differential expression under diet intervention.
However, the corresponding genes (mRNA) of the motif are not differentially expressed.

```{r}
plotdata = data.frame(
  statadjustededges = rowSums(statadjustededges))
foo = resultcomparedMotif[
  resultcomparedMotif$celltype == tgtct &
    resultcomparedMotif$sample == s, ]
plotdata$resultcomparedMotif =
  foo$statistic[match(sub("^Motif.", "", rownames(plotdata)), foo$genename)]
foo = resultcomparedGene[
  resultcomparedGene$celltype == tgtct &
    resultcomparedGene$sample == s, ]
plotdata$resultcomparedGene =
  foo$statistic[match(sub("^Motif.", "", rownames(plotdata)), foo$genename)]
ggplot(data = plotdata) +
  geom_point(
    aes(x = log1p(statadjustededges),
        y = resultcomparedMotif,
        col = resultcomparedGene)) +
  scale_color_gradient2(low = "blue", mid = "white", high = "red")
```

Clustering of motifs

```{r}
foo = statadjustededges[rowSums(statadjustededges) >= 200, ]
# heatmap(foo)
plot(
  hclust(dist(foo, method = "binary"), method = "average"),
  cex = 0.5)
```

## Detect mediator motifs by conditional analysis; mutual information

We want to detect the information flow (causality) "condition -> Motif i -> Gene j".
It doesn't matter whether there is bypass "condition -> Gene j".
In the language of entropy and mutual information, we detect by
mutual_info(Gene j; Motif i; condition) / entropy(Gene j) > 0.
Remark that
mutual_info(Gene j; Motif i; condition)
= mutual_info(Gene j; Motif i)
+ mutual_info(Gene j; condition)
- mutual_info(Gene j; Motif i, condition)
Instead of entropy and mutual information,
we actually use R2 (explained variance) of linear regression.

```{r}
x = matnrDEMotif
y = matnrDEGene
d = data.frame(
  m154207 = (matnrDEGene$Sample == "m154207"),
  m167203 = (matnrDEGene$Sample == "m167203"),
  m168101 = (matnrDEGene$Sample == "m168101"))
d = t(as.matrix(d) * 1)
```

```{r}
residualnull = rowSums( (assay(y) - rowMeans(assay(y)))^2 )

a1 = lm(t(assay(y)) ~ t(d))
R2diet = 1 - colSums(a1$residuals^2) / residualnull

cl = makeCluster(20)
clusterExport(cl, "assay")
clusterExport(cl, "x")
clusterExport(cl, "y")
clusterExport(cl, "d")
clusterExport(cl, "residualnull")
R2Motif =
  do.call(
    rbind,
    # lapply(
    parLapply(cl = cl,
              row.names(x),
              function (i) {
                a1 = lm(t(assay(y)) ~ assay(x)[i, ])
                1 - colSums(a1$residuals^2) / residualnull
              }))
R2Motifdiet =
  do.call(
    rbind,
    # lapply(
    parLapply(cl = cl,
              row.names(x),
              function (i) {
                print(i)
                a1 = lm(t(assay(y)) ~ cbind(assay(x)[i, ], t(d)))
                1 - colSums(a1$residuals^2) / residualnull
              }))
R2Motifdietmutual =
  R2Motif + matrix(R2diet, nrow = nrow(x), ncol = nrow(y), byrow = TRUE) - R2Motifdiet
R2Motifdietmutual[R2Motifdietmutual < 0] = 0
rownames(R2Motifdietmutual) = rownames(x)
# saveRDS(R2Motifdietmutual, paste0("R2Motifdietmutual.", tgtct, ".rds"))
R2Motifdietmutual = readRDS(paste0("R2Motifdietmutual.", tgtct, ".rds"))
```

```{r}
R2Motifdietmutual = readRDS(paste0("R2Motifdietmutual.", tgtct, ".rds"))
weightMatrix = readRDS(paste0("GENIE3.",  tgtct, ".rds"))
x = min(colQuantiles(weightMatrix, probs = 0.95))
weightMatrix = weightMatrix - x
weightMatrix[weightMatrix < 0] = 0
identical(colnames(R2Motifdietmutual), colnames(weightMatrix))
all(rownames(R2Motifdietmutual) %in%  rownames(weightMatrix))
foo = weightMatrix[rownames(R2Motifdietmutual), ]
plot(rowSums(R2Motifdietmutual), rowSums(foo))
plot(colSums(R2Motifdietmutual), colSums(foo))
```

Clean noise.

```{r}
plot(quantile(R2Motifdietmutual, seq(0, 1, 0.01)))
plot(quantile(R2Motifdietmutual, seq(1 - 1e-3, 1, 1e-5)))
plot(quantile(R2Motifdietmutual, seq(1 - 1e-4, 1, 1e-6)))

# Apparently unnecessary (nmf is not suited for sparse matrix)
# But actually improves GSEA of coef
x = min(colQuantiles(R2Motifdietmutual, probs = 0.95))
R2Motifdietmutual = R2Motifdietmutual - x
R2Motifdietmutual[R2Motifdietmutual < 0] = 0

# NG; take intersection with corMGsigsig
# nmf crashes for sparse matrix
# identical(rownames(R2Motifdietmutual), rownames(corMGsigsig))
# identical(colnames(R2Motifdietmutual), colnames(corMGsigsig))
# R2Motifdietmutual[corMGsigsig == 0] = 0

# plot(sort(rowMeans(R2Motifdietmutual)))
R2Motifdietmutual = R2Motifdietmutual[rowMeans(R2Motifdietmutual) > 0.001, ] # arbitrary

plot(hclust(dist(R2Motifdietmutual)))
```

Nonnegative matrix factorization.
Rank cutoff is not obvious from estim.r.
From GSEA of coef, rank = 4 for hepato

```{r}
library(NMF)

gc()
estim.r = nmf(R2Motifdietmutual,
              rank = 2:6,
              nrun = 30, # 10 30
              seed = 123456,
              .opt = 'vP4') # P5 error
# plot(estim.r)

set.seed(123456)
V.random = randomize(R2Motifdietmutual)
gc()
estim.r.random = nmf(V.random,
                     rank = 2:6,
                     nrun = 30, # 10 30
                     seed = 123456,
                     .opt = 'vP4')
plot(estim.r, estim.r.random)
rm(V.random)

res.nndsvd = nmf(R2Motifdietmutual,
                 rank = 4,
                 seed = 'nndsvd')
gc()
res = nmf(R2Motifdietmutual,
          rank = 4,
          nrun = 100, # 10 100
          seed = 123456,
          .opt = 'vP4')
summary(res.nndsvd, target = R2Motifdietmutual)
summary(res, target = R2Motifdietmutual)
# saveRDS(res, file = paste0("R2Motifdietmutual.NMF.", tgtct, ".rds"))
res = readRDS(paste0("R2Motifdietmutual.NMF.", tgtct, ".rds"))

basismap(res)
# coefmap(res)
```

# Multiple motifs-to-one gene analysis

## Compute regulatory motifs by using GENIE3

Include experimental condition as predictor.

```{r}
x = data.frame(
  m154207 = (matnrDEGene$Sample == "m154207"),
  m167203 = (matnrDEGene$Sample == "m167203"),
  m168101 = (matnrDEGene$Sample == "m168101"))
x = t(as.matrix(x) * 1)
```

For each gene, compute "regulatory" motifs.

```{r}
library(GENIE3)

set.seed(123)
weightMatrix = GENIE3(
  rbind(
    assay(matnrDEGene),
    assay(matnrDEMotif),
    x),
  targets = rownames(matnrDEGene),
  regulators = c(rownames(matnrDEMotif), rownames(x)),
  nCores = 22,
  verbose = TRUE)

# saveRDS(weightMatrix, file = paste0("GENIE3.",  tgtct, ".rds"))
weightMatrix = readRDS(paste0("GENIE3.",  tgtct, ".rds"))
```

Clean noise.

```{r}
plot(quantile(weightMatrix, seq(0, 1, 0.01)))
plot(quantile(weightMatrix, seq(1 - 1e-3, 1, 1e-5)))
plot(quantile(weightMatrix, seq(1 - 1e-4, 1, 1e-6)))

x = min(colQuantiles(weightMatrix, probs = 0.95))
weightMatrix = weightMatrix - x
weightMatrix[weightMatrix < 0] = 0

plot(sort(rowMeans(weightMatrix)))
weightMatrix = weightMatrix[rowMeans(weightMatrix) > 1e-4, ] # arbitrary
# stellate:    drops m167203 m168101 
# endothelial: drops m167203
# myelo:       drops m167203 m168101 
# T_NK:        drops all experimental conditions

# zero columns cause error in nmf
weightMatrix = weightMatrix[, colMaxs(weightMatrix) > 0]

plot(hclust(dist(weightMatrix)))
```

## Nonnegative matrix factorization of regulator-regulatee matrix

To choose the optimal value of r, first try 1; if not clear try 2.
1. (Hutchins2008) suggested to choose the first value where the RSS curve presents an inflection point, and (Frigyesi2008) considered the value of r after which the decrease in the RSS becomes lower than the decrease of the RSS obtained from random data.
2. (Brunet2004) proposed to take the value of r after which the cophenetic coefficient starts to drop steeply.

```{r}
library(NMF)

gc()
estim.r = nmf(weightMatrix,
              rank = 2:6,
              nrun = 30, # 10 30
              seed = 123456,
              .opt = 'vP4') # P5 error
# plot(estim.r)

set.seed(123456)
V.random = randomize(weightMatrix)
gc()
estim.r.random = nmf(V.random,
                     rank = 2:6,
                     nrun = 30, # 10 30
                     seed = 123456,
                     .opt = 'vP4')
# plot(estim.r, estim.r.random)
rm(V.random)

r = 4 # hepato stellate myelo
r = 3 # endothelial T_NK

# res.nndsvd = nmf(weightMatrix,
#                  rank = r,
#                  seed = 'nndsvd')

gc()
res = nmf(weightMatrix,
          rank = r,
          nrun = 100, # 10 100
          seed = 123456,
          .opt = 'vP4')
summary(res, target = weightMatrix)
# saveRDS(res, file = paste0("GENIE3.NMF.rank", r, ".", tgtct, ".rds"))
res = readRDS(paste0("GENIE3.NMF.rank", r, ".", tgtct, ".rds"))

basismap(res)
# coefmap(res)
summary(basis(res))
summary(t(coefficients(res)))
basis(res)["Motif.Hnf4g", ]
```

In `summary(t(coefficients(res)))`, one factor has large median and 3rd quantile.
Does it correspond to "all of the remaining genes"?
The basis for the  factor includes Motif.Hnf4g.
We set this factor as the last one in moduleindex.
Motif.Hnf4g is up in m154207 (HFD4w) and down in m168101 (washout).  Why??

This setting is for visualization.
We set the factor(s) with significant GSEA in the beginning (see below).

```{r}
# hepato
moduleindex = c(4, 2, 1, 3)
# stellate
moduleindex = c(1, 2, 4, 3)
# endothelial
moduleindex = c(3, 1, 2)
# myelo
moduleindex = c(3, 1, 2, 4)
# T_NK
moduleindex = c(2, 1, 3)
```

Draw heatmap for regulation of genes by motifs.

```{r}
topMotiflist = lapply(
  moduleindex,
  function (i) {
    x = sort(basis(res)[, i], decreasing = TRUE)
    x = x[! names(x) %in% grep("^m", names(x), value = TRUE)]
    x = x[x > max(x) / 2]
    return(head(names(x), 5))
  })
topMotif = union(do.call(c, topMotiflist), c())

topGenelist = lapply(
  moduleindex,
  function (i) {
    x = sort(coef(res)[i, ], decreasing = TRUE)
    x = x[x > max(x) / 2]
    return(head(names(x), 5))
  })
topGene = union(do.call(c, topGenelist), c())

weightMatrix = readRDS(paste0("GENIE3.",  tgtct, ".rds"))
x = t(weightMatrix[topMotif, topGene])
rownames(x) = sub("^Gene.", "", rownames(x))
colnames(x) = toupper(sub("^Motif.", "", colnames(x)))

aC = as.data.frame(basis(res)[topMotif, moduleindex])
names(aC) = paste0("Motif.M", 1:ncol(aC))
aR = as.data.frame(t(coef(res)[moduleindex, topGene]))
names(aR) = paste0("Gene.M", 1:ncol(aR))
NMF::aheatmap(
  x,
  color = c("white", "black"),
  annCol = aC,
  annRow = aR,
  annColors = rep(list(c("white", "black")), dim(res)[3] * 2),
  main = tgtct,
  treeheight = 0,
  filename = "NMF.heatmap.pdf", width = 5, height = 5)
```

## Gene set enrichment analysis for factors (modules) of the genes

Load `gslists` from `9_GSEA.Rmd`.

```{r}
x = as.data.frame(t(coef(res)))
row.names(x) = sub("^Gene.", "", row.names(x))
set.seed(123)
result =
  lapply(
    1:ncol(x),
    function (j) {
      print(j)
      lapply(
        gslists,
        function (gslist) {
          gslistresult =
            do.call(
              rbind,
              lapply(
                gslist,
                function (gs) {
                  ings = (row.names(x) %in% gs)
                  if (min(sum(ings), sum(! ings)) < 5) {
                    return(data.frame(statistic = NA, p.value = NA))
                  } else {
                    return(
                      as.data.frame(
                        t.test(
                          x[ings, j],
                          x[! ings, j],
                          alternative = "greater",
                          var.equal = TRUE)[c("statistic", "p.value")]))
                  }}))
          statisticnull =
            sapply(
              1:100,
              function (i) {
                sapply(
                  gslist,
                  function (gs) {
                    ings = (row.names(x) %in% gs)[sample(nrow(x))]
                    if (min(sum(ings), sum(! ings)) < 5) {
                      return(NA)
                    } else {
                      return(
                        t.test(
                          x[ings, j],
                          x[! ings, j],
                          alternative = "greater",
                          var.equal = TRUE)$statistic)
                    }})
              })
          statisticnull = colMaxs(statisticnull, na.rm = TRUE)
          gslistresult$fwe =
            sapply(
              gslistresult$statistic,
              function (s) { mean(s <= statisticnull) })
          return(gslistresult)
        })
    })
# saveRDS(result, file = paste0("GENIE3.NMF.rank", r, ".", tgtct, ".GSEA.rds"))
result = readRDS(paste0("GENIE3.NMF.rank", r, ".", tgtct, ".GSEA.rds"))
```

## Inspect enriched gene sets

When there are too many gene sets attaining family-wise error rate (fwe) < 0.05,
visualize and choose representatives by using Cytoscape:
1. Apps > EnrichmentMap. Import GMT file `foo.gmt`
2. Node Table. Import `foo.txt` and add column log10P
3. Style > Fill Color > Map. Column = log10Ppadog. Mapping Type = Continuous Mapping
4. [Optional] Apps > clusterMaker > MCODE Cluster. Create new clustered network
5. Layout > yFiles Radial Layout

Generate files to be loaded to Cytoscape.

```{r}
j = 1
data = result[[j]]
data = data[c(1:7, 9)]
data = do.call(rbind, data)
data$Name = rownames(data)
datafwe005 = data[!is.na(data$fwe) & data$fwe < 0.05, ]
datafwe005$log10P = log10(datafwe005$p.value)
datafwe005 = datafwe005[order(datafwe005$p.value), ]
datafwe005
datafwe005[order(datafwe005$Name), ]
datafwe005$Name2 = sub("[^.]*\\.", "", datafwe005$Name, perl = TRUE)
write.table(
  datafwe005[, c("Name2", "log10P")],
  file = "foo.txt",
  row.names = FALSE,
  col.names = TRUE,
  sep = "\t",
  quote = FALSE)

output = do.call(c, gslists)
output = output[datafwe005$Name]
output = lapply(output, function (x) { paste0(x, collapse = "\t") })
x = names(output)
x = sub("[^.]*\\.", "", x, perl = TRUE)
output = paste(
  x,
  sub("%.*", "", x),
  unlist(output),
  sep = "\t")
cat(output, file = "foo.gmt", sep = "\n")
```

Gene sets of interest are handpicked and sorted by biological process.

```{r}
# * indicates "not significant in diet comparison"
dbnamegsname = rbind(
  data.frame(dbname = 'GOBP', gsname = 'GOBP_STEROID_METABOLIC_PROCESS%%M16758'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_REGULATION_OF_CHOLESTEROL_BIOSYNTHESIS_BY_SREBP_SREBF%%M27001'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_LIPID_STORAGE%%M15541'),
  data.frame(dbname = 'KEGG', gsname = 'KEGG_PPAR_SIGNALING_PATHWAY%%M13088'),
  data.frame(dbname = 'H', gsname = 'HALLMARK_XENOBIOTIC_METABOLISM%%M5934'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608'),
  
  data.frame(dbname = 'H', gsname = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB%%M5890'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_CYTOKINE_PRODUCTION%%M13156'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_RESPONSE_TO_CYTOKINE%%M15783'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_INTERLEUKIN_1_SIGNALING%%M27895'),
  data.frame(dbname = 'H', gsname = 'HALLMARK_IL2_STAT5_SIGNALING%%M5947'), # *
  data.frame(dbname = 'H', gsname = 'HALLMARK_IL6_JAK_STAT3_SIGNALING%%M5897'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_INTERLEUKIN_10_SIGNALING%%M27605'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_INFLAMMASOMES%%M1072'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_ADAPTIVE_IMMUNE_RESPONSE%%M13847'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_CREATION_OF_C4_AND_C2_ACTIVATORS%%M1078'), # *
  data.frame(dbname = 'GOBP', gsname = 'GOBP_MYELOID_LEUKOCYTE_ACTIVATION%%M12762'),
  data.frame(dbname = 'KEGG', gsname = 'KEGG_HEMATOPOIETIC_CELL_LINEAGE%%M6856'), # *
  data.frame(dbname = 'WIKIPATHWAYS', gsname = 'WP_ONCOSTATIN_M_SIGNALING_PATHWAY%%M39562'),
  
  data.frame(dbname = 'KEGG', gsname = 'KEGG_APOPTOSIS%%M8492'),
  data.frame(dbname = 'H', gsname = 'HALLMARK_APOPTOSIS%%M5902'), # *
  
  data.frame(dbname = 'GOBP', gsname = 'GOBP_ACTIN_FILAMENT_BASED_PROCESS%%M9082'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_CELL_MIGRATION%%M40389'),
  # stellate
  data.frame(dbname ="REACTOME", gsname = "REACTOME_EXTRACELLULAR_MATRIX_ORGANIZATION%%M610"), # *
  data.frame(dbname = 'GOBP', gsname = 'GOBP_SEMAPHORIN_PLEXIN_SIGNALING_PATHWAY%%M15378'), # *
  data.frame(dbname = 'H', gsname = 'HALLMARK_TGF_BETA_SIGNALING%%M5896'), # *
  # endothelial
  data.frame(dbname = 'WIKIPATHWAYS', gsname = 'WP_VEGFAVEGFR2_SIGNALING_PATHWAY%%M39729'), # *
  
  data.frame(dbname = 'H', gsname = 'HALLMARK_MITOTIC_SPINDLE%%M5893'), # *
  data.frame(dbname = 'H', gsname = 'HALLMARK_KRAS_SIGNALING_UP%%M5953'), # *
  data.frame(dbname = 'H', gsname = 'HALLMARK_PI3K_AKT_MTOR_SIGNALING%%M5923'), # *

  data.frame(dbname = 'WIKIPATHWAYS', gsname = 'WP_FARNESOID_X_RECEPTOR_PATHWAY%%M39411'), # *
  data.frame(dbname = 'GOBP', gsname = 'GOBP_GLUTAMINE_FAMILY_AMINO_ACID_BIOSYNTHETIC_PROCESS%%M10295') # *
)
```

Visualize GSEA results.

```{r}
dataplot = lapply(result[moduleindex], function (x) do.call(rbind, x))
dataplot = lapply(dataplot, function (x) x[paste0(dbnamegsname$dbname, ".", dbnamegsname$gsname), ])

x = do.call(cbind, lapply(dataplot, function (x) x[, "p.value", drop = FALSE]))
names(x) =  paste0("Module ", 1:ncol(x))
x$gsname = factor(rownames(x), levels = rownames(x))
dataplot.P = x
x = do.call(cbind, lapply(dataplot, function (x) x[, "fwe", drop = FALSE]))
names(x) =  paste0("Module ", 1:ncol(x))
significant = (rowSums(is.na(x)) == 0) & (rowMins(as.matrix(x), na.rm = TRUE) < 0.05)
x$gsname = factor(rownames(x), levels = rownames(x))
dataplot.fwe = x
dataplot.P = dataplot.P[significant, , drop = FALSE]
dataplot.fwe = dataplot.fwe[significant, , drop = FALSE]

dataplot.P = tidyr::pivot_longer(dataplot.P,
                                 cols = matches("^Module \\d+", perl = TRUE),
                                 names_to = "factor",
                                 values_to = "P")
dataplot.fwe = tidyr::pivot_longer(dataplot.fwe,
                                   cols = matches("^Module \\d+", perl = TRUE),
                                   names_to = "factor",
                                   values_to = "fwe")
dataplot =
  dplyr::left_join(dataplot.P, dataplot.fwe, by = c("gsname", "factor"))

p1 =
  ggplot(dataplot,
         aes(x = gsname,
             y = - log10(P))) +
  geom_bar(stat = "identity",
           aes(fill = (fwe < 0.05))) +
  scale_fill_manual(values = c("gray50", "black")) +
  guides(fill = "none") +
  facet_grid(rows = vars(factor)) +
  theme(axis.text.x = element_text(angle = 90,
                                   hjust = 1,
                                   vjust = 0.5,
                                   size = rel(0.4))) +
  labs(title = tgtct,
       x = NULL)
show(p1)
# ggsave(p1, filename = "modulescore_GSEA.Gene.pdf", width = 3.15, height = 5.65)
```

## Visualize NMF VarianceImportance vs differential expression

```{r}
# Run this for Motif
x = as.data.frame(basis(res))
x = x[, moduleindex, drop = FALSE]
names(x) = paste0("Module ", 1:ncol(x))
x$genename = row.names(x)
x = tidyr::pivot_longer(x,
                        cols = matches("^Module \\d+", perl = TRUE),
                        names_to = "factor",
                        values_to = "score")
x$intop = FALSE
for (i in 1:length(topMotiflist)) {
  x$intop[(x$genename %in% topMotiflist[[i]]) &
            (x$factor == paste0("Module ", i))] = TRUE
}
x$genename = sub("^Motif.", "", x$genename)
dataplot = resultcomparedMotif %>%
  dplyr::filter(celltype == tgtct)

# Run this for Gene
x = as.data.frame(t(coef(res)))
x = x[, moduleindex, drop = FALSE]
names(x) = paste0("Module ", 1:ncol(x))
x$genename = row.names(x)
x = tidyr::pivot_longer(x,
                        cols = matches("^Module \\d+", perl = TRUE),
                        names_to = "factor",
                        values_to = "score")
x$intop = FALSE
for (i in 1:length(topGenelist)) {
  x$intop[(x$genename %in% topGenelist[[i]]) &
            (x$factor == paste0("Module ", i))] = TRUE
}
x$genename = sub("^Gene.", "", x$genename)
dataplot = resultcomparedGene %>%
  dplyr::filter(celltype == tgtct)

dataplot = dplyr::inner_join(dataplot, x, by = "genename")
p1 =
  ggplot(data = dataplot,
         aes(x = statistic,
             y = score)) +
  geom_point(aes(color = intop), size = 0.3) +
  scale_color_manual(values = c("black", "red"), guide = "none") +
  facet_grid(rows = vars(factor),
             cols = vars(sample),
             scales = "free_y") +
  labs(x = "Differential expression by diet [Z statistic]",
       y = "Module score") +
  theme(axis.text.x = element_text(size = rel(0.75)),
        axis.text.y = element_text(size = rel(0.75))) +
  theme(panel.spacing.y = unit(1, "lines"))
ggsave(p1, filename = "modulescore_DE.pdf", width = 3.5, height = 4)
```

Although all components could be associated with diet,
quantify to inspect which component is strongly associated with differential gene expression.

```{r}
library(dplyr)

x = as.data.frame(t(coef(res)))
x = x[, moduleindex, drop = FALSE]
names(x) = paste0("Module ", 1:ncol(x))
x$genename = sub("^Gene.", "", row.names(x))
x = tidyr::pivot_longer(x,
                        cols = matches("^Module \\d+", perl = TRUE),
                        names_to = "factor",
                        values_to = "score")
data = resultcomparedGene %>%
  dplyr::filter(celltype == tgtct)
data = dplyr::inner_join(data, x, by = "genename")

data %>%
  dplyr::group_by(factor, sample) %>%
  dplyr::summarize(
    statpos = summary(lm(statistic^2 ~ score + 0,
                         weights = score^2,
                         subset = statistic > 0))$coefficients[3],
    statneg = summary(lm(statistic^2 ~ score + 0,
                         weights = score^2,
                         subset = statistic < 0))$coefficients[3],
    .groups = "drop")
```

## SVD based on weighting by NMF factors (modules)

GENIE3 and NMF quantify the importance of genes/motifs as explained variance.
To infer the "directionality", we perform SVD by incorporating the variance as weight.
GENIE3 is a regression: each gene ~ motifs.
SVD and PCA are for extracting correlation.
Although the two concepts differ, it seems to work for assigning directionality.
We might say that genes/motifs highlighted in both approaches are robustly important.

```{r}
A = proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)]
A = as.factor(A)
```

Compute weight.

```{r}
x = t(coef(res))
x = x %*% diag(1 / colMeans(x))
x = sqrt(x) # convert from var to sd

wGene = x[match(rownames(matnrDEGene), row.names(x)), ]
wGene[is.na(wGene)] = 0
rownames(wGene) = rownames(matnrDEGene)

x = basis(res)
x = x %*% diag(1 / colMeans(x))
x = sqrt(x) # convert from var to sd

wMotif = x[match(rownames(matnrDEMotif), row.names(x)), ]
wMotif[is.na(wMotif)] = 0
rownames(wMotif) = rownames(matnrDEMotif)
```

Weighted SVD.

```{r}
identical(colnames(matnrDEGene), colnames(matnrDEMotif))

XGene = assay(matnrDEGene)
XGene = XGene - rowMeans(XGene)
XGene = XGene / rowSds(XGene)

XMotif = assay(matnrDEMotif)
XMotif = XMotif - rowMeans(XMotif)
XMotif = XMotif / rowSds(XMotif)

set.seed(123)
sXgslist = lapply(
  1:dim(res)[3],
  function (i) {
    irlba::irlba(rbind(XGene * wGene[, i], XMotif * wMotif[, i]))
  })

# For each factor, check if first element is much larger than the remaining.
# If not, the gene set is heterogeneous, which could be OK.
lapply(
  sXgslist,
  function (x) x$d)
```
SVD with permuted weight.
Check if the regulator motifs are correlated with regulatee genes.

```{r}
set.seed(123)
sXgsnull = sapply(
  1:dim(res)[3],
  function (i) { # factor
    print(i)
    sapply(
      1:100,
      function (j) { # permutation trial
        x = irlba::irlba(rbind(XGene * wGene[, i],
                               XMotif[, sample(ncol(XMotif))] * wMotif[, i]))
        data.frame(d1 = x$d[1])
      })
  },
  simplify = "array")

# For each NMF factor, check if first SVD component attains P < 0.05
lapply(
  1:dim(res)[3],
  function (i) {
    mean(as.numeric(sXgsnull[, i]) > sXgslist[[i]]$d[1])
  })
```
This setting is for visualization.
SVD direction for plotting.

```{r}
# hepato
sXgssign = c(1, -1, 1, 1)
# stellate
sXgssign = c(-1, -1, 1, 1)
# endothelial
sXgssign = c(-1, -1, -1)
# myelo
sXgssign = c(1, -1, 1, 1)
# T_NK
sXgssign = c(1, -1, 1)
```

Major Genes/Motifs for each NMF factor.

```{r}
lapply(
  1:dim(res)[3],
  function (i) {
    x = sXgslist[[i]]$u[1:nrow(XGene), 1] * sXgslist[[i]]$d[1]
    names(x) = row.names(XGene)
    x = sort(x * sXgssign[i])
    x = c(head(x, 5), tail(x, 5))
    dataplot = data.frame(
      order = 1:length(x),
      score = x,
      name = sub("^Gene.", "", names(x)),
      type = "Gene",
      module = paste0("Module ", which(moduleindex == i)))
    
    x = sXgslist[[i]]$u[nrow(XGene) + 1:nrow(XMotif), 1] * sXgslist[[i]]$d[1]
    names(x) = row.names(XMotif)
    x = sort(x * sXgssign[i])
    x = c(head(x, 5), tail(x, 5))
    dataplot = rbind(
      dataplot,
      data.frame(
        order = 1:length(x),
        score = x,
        name = toupper(sub("^Motif.", "", names(x))),
        type = "Motif",
        module = paste0("Module ", which(moduleindex == i))))
    
    dataplot$type = factor(dataplot$type, levels = c("Motif", "Gene"))
    p1 =
      ggplot(data = dataplot,
             aes(x = order,
                 y = score)) +
      geom_col() +
      geom_text(aes(label = name, y = - sign(score), hjust = -0.5 * sign(score) + 0.5), angle = -90) +
      theme(
        axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),
        axis.title.x = element_blank()) +
      labs(y = "Principal component score") +
      facet_grid(rows = vars(module), cols = vars(type))
    ggsave(p1,
           filename = paste0("GENIE3.NMF.rank", dim(res)[3], ".", tgtct, ".PCA.", i, ".pdf"),
           width = 5, height = 2)
    p1
  })
```
Relative expression level of diets, for each NMF factor.

```{r}
dataplot =
  do.call(
    rbind,
    lapply(
      1:dim(res)[3],
      function (i) {
        a0 = lm(
          sXgslist[[i]]$v[, 1] * sqrt(nrow(sXgslist[[i]]$v)) * sXgssign[i] ~
            0 + A)
        x = summary(a0)$coefficients[, 1:2]
        x = as.data.frame(x)
        x$diet = sub("^A", "", rownames(x))
        x$Module = paste0("Module ", which(moduleindex == i))
        return(x)
      }))
p1 =
  ggplot(data = dataplot,
         aes (x = diet,
              y = Estimate)) +
  geom_linerange(
    aes(ymin = Estimate - `Std. Error`,
        ymax = Estimate + `Std. Error`)) +
  geom_col() +
  labs(x = NULL,
       y = "Relative expression level of module") +
  facet_grid(rows = vars(Module))
ggsave(filename = paste0(tgtct, ".modulescore_diet.Gene.pdf"), p1,
       height = 3.5, width = 3)
```

## Stabilized regression

UNDER CONSTRUCTION

Do stably associated motifs `sr$results$SR$selection_probs > 0.9`
tend to be in cis with the gene?
Is StabilizedRegression better than GENIE3?

```{r}
library(StabilizedRegression)
sr.Gene.Abcg1 = SRanalysis(t(assay(matnrDEMotif)), assay(matnrDEGene)["Gene.Abcg1", ], proj6$spdietcombined[match(colnames(matnrDEMotif), proj6$cellNames)], num_reps = 10, pars = list(prescreen_size = 20), cores = 4, verbose = 2, seed = 123)
sr.Gene.Igfbp3 = SRanalysis(t(assay(matnrDEMotif)), assay(matnrDEGene)["Gene.Igfbp3", ], proj6$spdietcombined[match(colnames(matnrDEMotif), proj6$cellNames)], num_reps = 10, pars = list(prescreen_size = 20), cores = 4, verbose = 2, seed = 123)
sr.Gene.Il1r1 = SRanalysis(t(assay(matnrDEMotif)), assay(matnrDEGene)["Gene.Il1r1", ], proj6$spdietcombined[match(colnames(matnrDEMotif), proj6$cellNames)], num_reps = 10, pars = list(prescreen_size = 20), cores = 4, verbose = 2, seed = 123)
sr.Gene.Zfp37 = SRanalysis(t(assay(matnrDEMotif)), assay(matnrDEGene)["Gene.Zfp37", ], proj6$spdietcombined[match(colnames(matnrDEMotif), proj6$cellNames)], num_reps = 10, pars = list(prescreen_size = 20), cores = 4, verbose = 2, seed = 123)
sr$varnames[sr$results$SR$selection_probs > 0.9]
sr$varnames[sr$results$SR$selection_probs < 0.5 & sr$results$SRdiff$selection_probs > 0.9]
saveRDS(sr.Gene.Abcg1, file = paste0("sr.Gene.Abcg1.", tgtct, ".rds"))
```

Run `addMotifAnnotations` in 8_MotifMatrix.Rmd

```{r}
foo = readRDS(proj6@peakAnnotation@listData$Motif$Positions)
x = foo$Fos_104 # stable for Il1r1
x = foo$Bach1_108 # stable for Il1r1
x = foo$Nfkb1_701 # not stable for Il1r1
# Il1r1
x[seqnames(x) == "chr9" & abs(start(x) - 42540359) < 1e4, ]
```

# Multiple genes-to-one gene analysis

Include experimental condition as predictor.

```{r}
x = data.frame(
  m154207 = (matnrDEGene$Sample == "m154207"),
  m167203 = (matnrDEGene$Sample == "m167203"),
  m168101 = (matnrDEGene$Sample == "m168101"))
x = t(as.matrix(x) * 1)
```

Gene-gene regulation

```{r}
library(GENIE3)

set.seed(123)
weightMatrix = GENIE3(
  rbind(
    assay(matnrDEGene),
    x),
  targets = rownames(matnrDEGene),
  regulators = c(rownames(matnrDEGene), rownames(x)),
  nCores = 22,
  verbose = TRUE)

# saveRDS(weightMatrix, file = paste0("GENIE3_GeneGene.",  tgtct, ".rds"))
weightMatrix = readRDS(paste0("GENIE3_GeneGene.",  tgtct, ".rds"))
rownames(weightMatrix) = sub("^Gene.", "", rownames(weightMatrix))
colnames(weightMatrix) = sub("^Gene.", "", colnames(weightMatrix))
```

Clean noise.

```{r}
plot(quantile(weightMatrix, seq(0, 1, 0.01)))
plot(quantile(weightMatrix, seq(1 - 1e-3, 1, 1e-5)))
plot(quantile(weightMatrix, seq(1 - 1e-4, 1, 1e-6)))

x = median(colQuantiles(weightMatrix, probs = 0.95))
weightMatrix = weightMatrix - x
weightMatrix[weightMatrix < 0] = 0

plot(sort(rowMeans(weightMatrix)))
```

Find key genes for a target gene set.
Load `gslists` from `9_GSEA.Rmd`.

```{r}
dbname = 'REACTOME'; gsname = 'REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227'
dbname = 'GOBP'; gsname = 'GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829'
dbname = 'KEGG'; gsname = 'KEGG_PPAR_SIGNALING_PATHWAY%%M13088'
dbname = 'H'; gsname = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB%%M5890'
dbname = 'KEGG'; gsname = 'KEGG_APOPTOSIS%%M8492'
dbname = 'GOBP'; gsname = 'GOBP_CELL_MIGRATION%%M40389'
dbname = 'REACTOME'; gsname = 'REACTOME_EXTRACELLULAR_MATRIX_ORGANIZATION%%M610'
dbname = 'GOBP'; gsname = 'GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608'
gs = gslists[[ dbname ]][[ gsname ]]
```

```{r}
data = data.frame(
  genename = rownames(weightMatrix),
  score = rowSums(weightMatrix[, colnames(weightMatrix) %in% gs])
)
data = dplyr::left_join(data,
                        as.data.frame(geneAnnotation$genes),
                        by = c("genename" = "symbol"))
t.test(data$score[data$genename %in% gs], data$score[! data$genename %in% gs])
tail(data[order(data$score), ], 20)
```

The enrichment is weak.
Was `nrow(matnrDEGene)` predictors too many for GENIE3?

# Multiple genes-to-trait analysis

A gene set represents a trait, for which we want to find key genes.

Load `gslists` from `9_GSEA.Rmd`.

```{r}
dbname = 'REACTOME'; gsname = 'REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227'
dbname = 'GOBP'; gsname = 'GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829'
dbname = 'KEGG'; gsname = 'KEGG_PPAR_SIGNALING_PATHWAY%%M13088'
dbname = 'H'; gsname = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB%%M5890'
dbname = 'KEGG'; gsname = 'KEGG_APOPTOSIS%%M8492'
dbname = 'GOBP'; gsname = 'GOBP_CELL_MIGRATION%%M40389'
dbname = 'REACTOME'; gsname = 'REACTOME_EXTRACELLULAR_MATRIX_ORGANIZATION%%M610'
dbname = 'GOBP'; gsname = 'GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608'
gs = gslists[[ dbname ]][[ gsname ]]
```

The first PC of the target gene set is modeled as the dependent variable `gslevel`.

```{r}
x = assay(matnrDEGene)
x = x[rownames(x) %in% paste0("Gene.", gs), ]
# exclude top gene(s)
# x = x[! rownames(x) %in% paste0("Gene.", c("Hmgcs1")), ]
# x = x[! rownames(x) %in% paste0("Gene.", c("Il1r1")), ]
# x = x[! rownames(x) %in% paste0("Gene.", c("Igfbp3")), ]
x = x - rowMeans(x)
x = x / rowSds(x)
s = svd(x)

# gslevel = s$v[, 1] # pc
gslevel = t(x) %*% sign(s$u[, 1]) # average; equal weight on all genes

plot(s$d)
sum(s$d^2) / s$d[1]^2

# Check batch effect
ggplot(data = as.data.frame(s$v)) +
  geom_violin(
    aes(x = proj6$Sample[match(colnames(x), proj6$cellNames)],
        y = V1)) 
summary(lm(s$v[, 1] ~ 0 + proj6$Sample[match(colnames(x), proj6$cellNames)]))
ggplot(data = as.data.frame(s$v),
       aes(x = V1,
           y = V2)) +
  geom_point() +
  facet_grid(rows = vars(proj6$Sample[match(colnames(x), proj6$cellNames)])) +
  geom_rug()

ggplot(data = as.data.frame(s$u),
       aes(x = V1, y = V2)) +
  geom_text(aes(label = sub("^Gene.", "", rownames(x))))
```

Stabilized regression with genes as independent variables and `gslevel` as dependent variable

```{r}
library(StabilizedRegression)

prescreen_size = round(min(table(
  proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)]
))/2)
```

Try a range of `size_weight`

```{r}
swlist = seq(2, 60, 2)
srlist =
  lapply(
    swlist,
    function (sw) {
      print(sw)
      StabilizedRegression(
        t(assay(matnrDEGene)),
        gslevel,
        proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)],
        pars = list(B = 1000,
                    # stab_test = "mean_sres",
                    stab_test = "mean_sres_score",
                    alpha_stab = 1, # force to choose Top 10 percent of sets
                    size_weight = seq(1, sw),
                    prescreen_size = prescreen_size),
        verbose = 2,
        seed = 123)
    })
names(srlist) = swlist
```

Under `stab_test = "mean_sres"`,
`pval_stab` is not calibrated (probably due to large sample size),
as seen in `pval_stab_median` being much smaller than 0.5 (plotted below).
Thus, we cannot used alpha_stab = 0.05 as cutoff.
Instead, we use `stab_test = "mean_sres_score"`.

In predmods_stab_pval_stab_mse.pdf,
as `sw` increases,
`predmods_stab_pval_stab` increases (good)
and `predmods_stab_mse` decreases (good).
The change is gradual, and there is no optimal `sw`.

```{r}
dataplot = do.call(
  rbind,
  lapply(
    srlist,
    function (x) {
      data.frame(
        pval_stab_median =
          median(sapply(x$learner_list, function (l) l$scores[1])), # this is median(pval_stab)
        predmods_stab_pval_stab =
          median(sapply(x$learner_list, function (l) l$scores[1])[x$weighting > 0]),
        predmods_stab_mse =
          median(sapply(x$learner_list, function (l) l$scores[2])[x$weighting > 0]),
        variable_importance_pos =
          sum(x$variable_importance > 0)
      )}))
dataplot$sw = as.numeric(rownames(dataplot))

plot(dataplot[, c("sw", "pval_stab_median")])
plot(dataplot[, c("sw", "variable_importance_pos")])

p1 =
  ggplot(
    data = dataplot,
    aes(x = predmods_stab_pval_stab,
        y = predmods_stab_mse)) +
  geom_text(aes(label = sw), size = 2)
ggsave(p1, file = "predmods_stab_pval_stab_mse.pdf", width = 6, height = 6)
```

Actual run of stabilized regression

```{r}
sw = round(sum(s$d^2) / s$d[1]^2)
# B = 1000
B = 5000
# B = round(prescreen_size^2 / ((sw+1)/2) / (((sw+1)/2)-1)) # for each variable pair, expect 1 set to include both

sr = SRanalysis(
  t(assay(matnrDEGene)),
  gslevel,
  proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)],
  num_reps = 100,
  pars = list(B = B,
              stab_test = "mean_sres_score",
              alpha_stab = 1, # force to choose Top 10 percent of sets
              size_weight = seq(1, sw),
              prescreen_size = prescreen_size),
  verbose = 2,
  seed = 123)

# saveRDS(sr, file = paste0("sr_pc.", tgtct, ".", gsname, ".", sw, ".rds"))
# saveRDS(sr, file = paste0("sr_average.", tgtct, ".", gsname, ".", sw, ".rds"))
# saveRDS(sr, file = paste0("sr_average.", tgtct, ".", gsname, ".", sw, ".", B, ".rds"))
# sr = readRDS(paste0("sr_pc.", tgtct, ".", gsname, ".", sw, ".rds"))
sr = readRDS(paste0("sr_average.", tgtct, ".", gsname, ".", sw, ".rds"))
sr = readRDS(paste0("sr_average.", tgtct, ".", gsname, ".", sw, ".", B, ".rds"))
```

IF NOT WORKING, DELETE.
Prescreen by correlation and stability.
This could improve SR, but skew SRpred.

```{r}
sr1 = StabilizedRegression(
  t(assay(matnrDEGene)),
  gslevel,
  proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)],
  pars = list(m = 1,
              B = NA,
              stab_test = "mean_sres_score",
              prescreen_size = prescreen_size * 2),
  verbose = 2,
  seed = 123)

sr1result = do.call(
  rbind,
  lapply(
    sr1$learner_list[-1], # omit empty set
    function (l) {
      data.frame(
        pval_stab = l$scores[1],
        pred_score = l$scores[2],
        index = l$S)}))
sr1result$genename = names(sr1$variable_importance)[sr1result$index]

prescreened_genename =
  sr1result$genename[
    sr1result$pval_stab >=
      sort(sr1result$pval_stab, decreasing = TRUE)[prescreen_size]]

# pdf("foo.pdf")
# plot(sr1result[, c("pred_score", "pval_stab")])
# dev.off()
# pdf("goo.pdf")
# plot(sr1result[sr1result$genename %in% prescreened_genename,
#                c("pred_score", "pval_stab")])
# dev.off()

sw = round(sum(s$d^2) / s$d[1]^2)
# B = 1000
B = 5000

sr = SRanalysis(
  t(assay(matnrDEGene))[, prescreened_genename],
  gslevel,
  proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)],
  num_reps = 100,
  pars = list(B = B,
              stab_test = "mean_sres_score",
              alpha_stab = 1, # force to choose Top 10 percent of sets
              size_weight = seq(1, sw)),
  verbose = 2,
  seed = 123)

# saveRDS(sr, file = paste0("sr_average_prescreen_cor_stab.", tgtct, ".", gsname, ".", sw, ".", B, ".rds"))
sr = readRDS(paste0("sr_average_prescreen_cor_stab.", tgtct, ".", gsname, ".", sw, ".", B, ".rds"))
```

Inspect result

```{r}
sr$varnames[sr$results$SR$selection_probs > 0.5]
sr$varnames[sr$results$SRdiff$selection_probs > 0.5]
ggplot(
  data = cbind(as.data.frame(t(assay(matnrDEGene))),
               data.frame(gslevel = gslevel,
                          Sample = as.character(matnrDEGene$Sample))),
  aes(
    # x = Gene.Hmgcs1, # REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227
    # x = Gene.Cyp2a2, # GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829 suggestive
    # x = Gene.Il1r1, # KEGG_APOPTOSIS%%M8492
    x = Gene.Bcl2l1, # KEGG_APOPTOSIS%%M8492 suggestive
    # x = Gene.Il1r1, # GOBP_CELL_MIGRATION%%M40389 suggestive
    # x = Gene.Ccr5, # GOBP_CELL_MIGRATION%%M40389 nonstable
    # x = Gene.Igfbp3, # GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608
    y = gslevel)) +
  geom_point(size = 0.3) +
  stat_smooth(method = lm) +
  facet_grid(cols = vars(Sample))
```

# Differential expression and co-regulation of a gene set

For a given gene set, the following might be confused but are different:
1. Genes that are differentially expressed among conditions
2. "Core" genes in co-regulation, here defined as co-regulated with many other genes

Load `gslists` from `9_GSEA.Rmd`.

```{r}
dbname = 'REACTOME'; gsname = 'REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227'
dbname = 'GOBP'; gsname = 'GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829'
dbname = 'KEGG'; gsname = 'KEGG_PPAR_SIGNALING_PATHWAY%%M13088'
dbname = 'H'; gsname = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB%%M5890'
dbname = 'GOBP'; gsname = 'GOBP_RESPONSE_TO_CYTOKINE%%M15783'
dbname = 'GOBP'; gsname = 'GOBP_ADAPTIVE_IMMUNE_RESPONSE%%M13847'
dbname = 'KEGG'; gsname = 'KEGG_APOPTOSIS%%M8492'
dbname = 'GOBP'; gsname = 'GOBP_APOPTOTIC_PROCESS%%M34075'
dbname = 'GOBP'; gsname = 'GOBP_CELL_MIGRATION%%M40389'
dbname = 'REACTOME'; gsname = 'REACTOME_EXTRACELLULAR_MATRIX_ORGANIZATION%%M610'
dbname = 'GOBP'; gsname = 'GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608'
gs = gslists[[ dbname ]][[ gsname ]]
```

Load STRING protein-protein interaction with gs

```{r}
string = data.table::fread(
  file = "~/human/publicrat/STRING/10116.protein.links.name.txt",
  sep ="\t")
string = string[string$protein1 != string$protein2, ]
string = string[string$protein2 %in% gs, ]
string = string %>%
  # dplyr::filter(combined_score >= 0.4) %>%
  dplyr::select(-c("protein2")) %>%
  dplyr::group_by(protein1) %>%
  dplyr::summarize(ppinteractionwithgs = sum(combined_score))

t.test(string$ppinteractionwithgs[string$protein1 %in% gs], 
       string$ppinteractionwithgs[! string$protein1 %in% gs])
```

## Differential expression

In the code block below, check if the genes in the gene set are co-regulated.
In the next block, check if the expression level differs among diet conditions.
In total, there are three points to check statistical significance.

As a first attempt, use `matnrDEGene`, which should include less noise.
If failed, try with `matnrGene`. (Really??)
If also failed, discard the gene set.

```{r}
X = assay(matnrDEGene)
A = proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)]
# X = assay(matnrGene)
# A = proj6$spdietcombined[match(colnames(matnrGene), proj6$cellNames)]

X = X - rowMeans(X)
X = X / rowSds(X)
A = as.factor(A)

Xgs = X[rownames(X) %in% paste0("Gene.", gs), ]
sXgs = svd(Xgs)

set.seed(123)
sXgsdnull = sapply(
  1:100,
  function (i) {
    Xgspermute = X[sample(1:nrow(X), nrow(Xgs)), ]
    return(svd(Xgspermute)$d)
  })

# Check if first element attains P < 0.05
head(rowMeans(sXgsdnull > sXgs$d))

# Check if first element is much larger than the remaining.
# If not, the gene set is heterogeneous, and discarded.
plot(sXgs$d)

# dataplot = as.data.frame(sXgs$u)
# dataplot$genename = rownames(Xgs)
# ggplot(data = dataplot,
#        aes(x = V1, y = V2)) +
#   geom_text(
#     aes(
#       label = sub("^Gene.", "", genename)))
```

For the 1st principal component computed above, check if diet conditions differ.
If so, compute the average expression level `gslevel` of the gene set in each condition.

```{r}
plot(A, sXgs$v[, 1])
a0 = lm(sXgs$v[, 1] ~ A)
# Check significance
anova(a0)

x = tapply(sXgs$v[, 1], A, mean)
x = x[A]
x = x - mean(x)
# rescale to sd = 0.5 (as in the typical scenario where half are zero and half are one)
gslevel = x / sd(x) / 2 
names(gslevel) = colnames(X)

tapply(gslevel, A, mean)
ggplot(data = data.frame(
  A = levels(A),
  gslevel = tapply(gslevel, A, mean)),
  aes (x = A,
       y = gslevel)) +
  geom_col() +
  labs(x = NULL,
       y = "Relative expression level of gene set")
```

Differential gene expression against `gslevel`

```{r}
identical(colnames(matnrGene), names(gslevel))
resultcompared = broom::tidy(
  lm(y ~ x,
     data = list(
       y = t(assay(matnrGene)),
       x = gslevel)))
resultcompared = resultcompared[resultcompared$term == "x", ]
colnames(resultcompared)[colnames(resultcompared) == "p.value"] = "p"
resultcompared$FDR = p.adjust(resultcompared$p, method = "BH")
colnames(resultcompared)[colnames(resultcompared) == "response"] = "genename"
resultcompared$ings = resultcompared$genename %in% paste0("Gene.", gs)
```

Volcano plot

```{r}
dataplot = resultcompared %>%
  dplyr::filter(ings)
dataplot$log10p = log10(dataplot$p)
x = is.infinite(dataplot$log10p)
dataplot$log10p[x] = min(dataplot$log10p[! x])

fig = ggplot(data = dataplot) +
  geom_point(
    aes(x = 2^estimate,
        y = - log10p,
        col = statistic),
    size = 0.3) +
  scale_x_log10() +
  scale_color_gradient2(low = "blue", mid = "black", high = "red", midpoint = 0) + # TODO IMPROVE
  labs(
    x = "Fold change",
    y = "-log10(P)")
show(fig)
ggsave("foo.pdf", fig, width = 6, height = 8)
```

Combine with ppinteractionwithgs

```{r}
dataplot = resultcompared

dataplot$ppinteractionwithgs =
  string$ppinteractionwithgs[
    match(dataplot$genename, paste0("Gene.", string$protein1))]
dataplot$ppinteractionwithgs[
  is.na(dataplot$ppinteractionwithgs)] = 0

dataplot$diffaccinteract = "DiffAcc_LowPPIGS"
dataplot$diffaccinteract[
  dataplot$ppinteractionwithgs >
    quantile(dataplot$ppinteractionwithgs, 0.95)] = "DiffAcc_HighPPIGS"
dataplot$diffaccinteract[
  abs(dataplot$estimate) <= log2(1.1) |
    dataplot$FDR >= 0.01] = "NotDiffAcc"
dataplot$geneset2 = "Genes not in GS"
dataplot$geneset2[dataplot$ings] = "Genes in GS"
ggplot(
  data = dataplot,
  aes(x = statistic,
      y = ppinteractionwithgs)) +
  geom_point(aes(color = diffaccinteract),
             size = 0.5) +
  facet_grid(rows = vars(geneset2)) +
  scale_color_manual(values = c("Red", "Blue", "Black")) +
  labs(x = "Z-score for differential accessiblity",
       y = "Total protein-protein interactions with GS",
       title = paste0(gsname, "\n", tgtct))
```

## Co-regulation

To find "core" genes in co-regulation, we analyze co-regulation within diet/condition.
Use `matnrDEGene`, which should include less noise.

```{r}
# X = assay(matnrGene)
# A = proj6$spdietcombined[match(colnames(matnrGene), proj6$cellNames)]
X = assay(matnrDEGene)
A = proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)]

X = X - rowMeans(X)
A = as.factor(A)
Alist = lapply(unique(A), function(a) which(A == a))

# Y = within environment dispersion
# Z = between environment dispersion
Z = X * 0
for (ind in Alist) {
  m = rowMeans(X[, ind])
  Z[, ind] = m
  rm(m)
}
Y = X - Z
Y = Y / rowSds(Y)

Ygs = Y[rownames(Y) %in% paste0("Gene.", gs), ]
Ygs = Ygs[rownames(Ygs) != "Gene.Il1b", ]  # Next to Gene.Il1a;  KEGG_APOPTOSIS%%M8492
Ygs = Ygs[rownames(Ygs) != "Gene.Birc2", ] # Next to Gene.Birc3; KEGG_APOPTOSIS%%M8492
```

## Co-regulation; PCA

Plot first few principal components.

```{r}
sYgs = svd(Ygs)

set.seed(123)
sYgsdnull = sapply(
  1:100,
  function (i) {
    Ygspermute = Y[sample(1:nrow(Y), nrow(Ygs)), ]
    return(svd(Ygspermute)$d)
  })

# Do the first few element attains P < 0.05 ?
# From a descriptive statistics viewpoint, we don't care.
head(rowMeans(sYgsdnull > sYgs$d))
plot(sYgs$d)

dataplot = as.data.frame(sYgs$u)
dataplot$genename = rownames(Ygs)
dataplot$statistic = resultcompared$statistic[match(dataplot$genename, resultcompared$genename)]

# Are there new genes not in gs?  Not really.
quantile(sYgs$u - Ygs %*% sYgs$v %*% diag(1 / sYgs$d), c(0, 1))
dataplot = as.data.frame(Y %*% sYgs$v %*% diag(1 / sYgs$d))
dataplot$genename = rownames(dataplot)
dataplot$statistic = resultcompared$statistic[match(dataplot$genename, resultcompared$genename)]

ggplot(data = dataplot,
       aes(x = V1, y = V2)) +
  geom_text(
    aes(
      label = sub("^Gene.", "", genename),
      col = statistic),
    size = 3) +
  scale_color_gradient2(low = "blue", mid = "black", high = "red", midpoint = 0) + # TODO IMPROVE
  labs(x = paste0("PC 1 (", sprintf("%.3f", sYgs$d[1]^2 / sum(sYgs$d^2)), " of total variance)" ),
       y = paste0("PC 2 (", sprintf("%.3f", sYgs$d[2]^2 / sum(sYgs$d^2)), " of total variance)" ))
```

## Co-regulation; GENIE3

Gene-gene regulation

```{r}
library(GENIE3)

set.seed(123)
weightMatrix = GENIE3(
  Ygs,
  nCores = 22,
  verbose = TRUE)

# saveRDS(weightMatrix, file = paste0("GENIE3_GeneGene.",  tgtct, ".", gsname, ".rds"))
weightMatrix = readRDS(paste0("GENIE3_GeneGene.",  tgtct, ".", gsname, ".rds"))
rownames(weightMatrix) = sub("^Gene.", "", rownames(weightMatrix))
colnames(weightMatrix) = sub("^Gene.", "", colnames(weightMatrix))

heatmap(weightMatrix, Rowv = NA, Colv = NA, scale = "none", cexRow = 0.5, cexCol = 0.5)
```

Clean noise.

```{r}
plot(sort(as.numeric(weightMatrix)))
# x = median(colQuantiles(weightMatrix, probs = 0.95))
x = median(
  apply(
    weightMatrix,
    2,
    function (x) sort(x, decreasing = TRUE)[3])) # keep top 3 regulators
abline(a = x, b = 0)
weightMatrix = weightMatrix - x
weightMatrix[weightMatrix < 0] = 0

heatmap(weightMatrix, Rowv = NA, Colv = NA, scale = "none", cexRow = 0.5, cexCol = 0.5)
heatmap(1*(weightMatrix>0), Rowv = NA, Colv = NA, scale = "none", cexRow = 0.5, cexCol = 0.5)
plot(sort(rowMeans(weightMatrix)))
plot(sort(rowMeans(weightMatrix > 0)))
tail(sort(rowMeans(weightMatrix)))
tail(sort(rowMeans(weightMatrix > 0)))
tail(sort(colMeans(weightMatrix)))
tail(sort(colMeans(weightMatrix > 0)))
plot(rowMeans(weightMatrix), rowMeans(weightMatrix > 0)) # diagonal
plot(colMeans(weightMatrix), colMeans(weightMatrix > 0)) # no
```

Represent regulatory relation in directed graph.

```{r}
library(igraph)
links = data.frame(
  source = rep(rownames(weightMatrix), times = ncol(weightMatrix)),
  target = rep(colnames(weightMatrix), each = nrow(weightMatrix)),
  weight = as.numeric(weightMatrix))
links = links[links$weight > 0, ]
nodes = data.frame(
    name = unique(c(links$source, links$target)))
nodes$statistic = resultcompared$statistic[
  match(paste0("Gene.", nodes$name), resultcompared$genename)]
# nodes$color = gray(
#   (nodes$statistic - min(nodes$statistic)) /
#     (max(nodes$statistic) - min(nodes$statistic)))
nodes$color = rgb(
  1 + (nodes$statistic / max(abs(nodes$statistic))) * (nodes$statistic < 0),
  1 - (nodes$statistic / max(abs(nodes$statistic))) * (nodes$statistic > 0),
  1 - (nodes$statistic / max(abs(nodes$statistic))) * (nodes$statistic > 0))
# nodes$outdegree = rowSums(weightMatrix)[nodes$name]
# nodes$outdegree = nodes$outdegree / max(nodes$outdegree)
# outdegree = rowSums(weightMatrix)
outdegree = rowSums(weightMatrix > 0)
outdegree = outdegree / max(outdegree)

network = graph_from_data_frame(d = links, vertices = nodes, directed = TRUE)
plot(network)
set.seed(123)
plot(network,
     # edge.width = rank(E(network)$weight)/30,
     # edge.width = E(network)$weight * 100,
     # vertex.size = eigen_centrality(network)$vector * 10 + 5,
     vertex.size = outdegree[V(network)$name] * 10 + 5,
     vertex.frame.color = NA,
     edge.curved = 0.3,
     edge.arrow.size = 0.6,
     layout=layout_with_dh)
  # layout=layout_with_gem)
  # layout=layout_with_graphopt)
  # layout=layout_with_lgl)
```

