---
title: "GRN"
output: html_notebook
---

Apart from the section "Preprocess", other sections can be executed independently.

# Preprocess

Target cell type

```{r}
tgtct =
  "hepato"
  # "stellate"
  # "endothelial"
  # "myelo"
  # "T_NK"
```

Beforehand,
load `resultcompared` from `7_GeneScoreMatrix.Rmd` and rename to `resultcomparedGene`.
Load `redundantGene` and `matnrGene` from `7_GeneScoreMatrix.Rmd`.
Load `resultcompared` from `8_MotifMatrix.Rmd` and rename to `resultcomparedMotif`.
Load `redundantMotif` and `matnrMotif` from `8_MotifMatrix.Rmd`.

```{r}
identical(colnames(matnrGene), colnames(matnrMotif))
```

Inspect.

```{r}
ggplot(data = data.frame(
  x = assay(matnrGene)["Gene.Abcg1", ],
  y = assay(matnrMotif)["Motif.Stat5b", ],
  s = as.character(matnrGene$Sample)),
  aes(x, y)) +
  geom_point(size = 0.5) +
  facet_grid(cols = vars(s))
```

Filter differentially expressed genes/motifs.
For robustness, we impose abs(estimate) > log2(1.1), which is arbitrary (especially for Motif).

```{r}
x = resultcomparedGene %>%
  dplyr::filter(abs(estimate) > log2(1.1) & FDR < 0.01 & celltype == tgtct) %>%
  dplyr::distinct(genename) %>%
  dplyr::pull(genename)
matnrDEGene = matnrGene[which(rownames(matnrGene) %in% paste0("Gene.", x)), ]

x = resultcomparedMotif %>%
  dplyr::filter(abs(estimate) > log2(1.1) & FDR < 0.01 & celltype == tgtct) %>%
  dplyr::distinct(genename) %>%
  dplyr::pull(genename)
matnrDEMotif = matnrMotif[which(rownames(matnrMotif) %in% paste0("Motif.", x)), ]
```

# One motif-to-one gene analysis

## Correlation between motifs and genes

```{r}
corMG = cor(
  t(assay(matnrMotif)),
  t(assay(matnrGene)),
  method = "spearman")

cornulldistribution =
  sapply(
    1:100,
    function (i) {
      print(i)
      set.seed(i)
      corMGsim = cor(
        t(assay(matnrMotif))[sample(ncol(matnrMotif)), ],
        t(assay(matnrGene)),
        method = "spearman")
      sapply(0:1000, function (x) { sum(abs(corMGsim) > x/1000) })
    })

thresholdFDR001 =
  max(which(
    rowMeans(cornulldistribution) /
      sapply(0:1000, function (x) { sum(abs(corMG) > x/1000) }) >= 0.01)) / 1000
# FDR<0.01
# >0.035 ; hepato

thresholdglobalP005 =
  mean(sort(
    apply(
      cornulldistribution,
      2,
      function (x) { (max(which(x > 0)) - 1)/1000 }),
    decreasing = TRUE)[5:6])
# globalP=0.05
# 0.062 ; hepato

# Mask unless FDR<0.01
corMGsig = corMG
corMGsig[abs(corMGsig) <= thresholdFDR001] = 0
```

Filter differentially expressed genes/motifs.

```{r}
all(rownames(matnrDEMotif) %in% rownames(corMGsig))
all(rownames(matnrDEGene)  %in% colnames(corMGsig))
corMGsigsig = corMGsig
corMGsigsig = corMGsigsig[rownames(matnrDEMotif), ]
corMGsigsig = corMGsigsig[, rownames(matnrDEGene)]
plot(quantile(abs(corMGsigsig), seq(0, 1, 0.01)))
```

## SVD of corMGsigsig

For hepato, 7 components look significant.
They tend to overlap with factors (modules) found below
in section 'Multiple motifs-to-one gene analysis'

```{r}
x = svd(corMGsigsig)
plot(x$d)
dataplot =
  as.data.frame(x$u); rownames(dataplot) = rownames(corMGsigsig)
  # as.data.frame(x$v); rownames(dataplot) = colnames(corMGsigsig)
ggplot(data = dataplot,
       aes(x = V1,
           y = V2)) +
  geom_point(size = 0.5)

i = 1
w = x$u[, i]
names(w) = rownames(corMGsigsig)
w[head(order(abs(w), decreasing = TRUE), 10)]
w = x$v[, i]
names(w) = colnames(corMGsigsig)
w[head(order(abs(w), decreasing = TRUE), 10)]
```

## Graph of corMGsigsig

```{r}
library(igraph)

x = as.character()
for (j in 1:ncol(corMGsigsig)) {
  connected = corMGsigsig[, j]
  connected = connected[abs(connected) > 0]
  if (length(connected) > 0) {
    connected = connected[head(order(abs(connected), decreasing = TRUE), 5)]
    x = c(x,
          as.character(
            rbind(
              names(connected),
              colnames(corMGsigsig)[j])
          ))
  }
}
corMGsigsiggraph = graph(edges = x, directed = TRUE)
corMGsigsiggraphcomp = igraph::components(corMGsigsiggraph, mode = "weak")
corMGsigsiggraphcomp$csize
head(sort(degree(corMGsigsiggraph), decreasing = TRUE))
```

## Detect mediator motifs by conditional analysis; diminished t-statistic

We are interested if the effect of condition (ie diet) on Gene j
is mediated by Motif i.
We want to detect the information flow (causality) "condition -> Motif i -> Gene j".
It doesn't matter whether there is bypass "condition -> Gene j".
We test if the association of Gene j with condition decreases
when conditioned by Motif i.

```{r}
x = matnrDEMotif
y = matnrDEGene
g = x$Sample
g[g %in% c("m154211", "m167108")] = "sp"
x$spdietcombined = g
```

Compute the regression
condition ~ (Motif i) + (Gene j),
and keep the t-statistic for (Gene j).
For a fixed j, which i yields diminished t-statistic?

```{r}
cl = makeCluster(20)
clusterExport(cl, "assay")
clusterExport(cl, "x")
clusterExport(cl, "y")
# TODO CCA with all conditions combined as y
statadjusted =
  do.call(
    rbind,
    lapply(
      c("m154207", "m167203", "m168101"),
      function (s) {
        print(s)
        cond = as.character(x$spdietcombined)
        cond[! cond %in% c(s, "sp")] = NA
        do.call(
          rbind,
          lapply(
            row.names(x),
            function (i) {
              print(i)
              do.call(
                rbind,
                # lapply(
                parLapply(cl = cl,
                  row.names(y),
                  function (j) {
                    a0 = lm(y ~ x,
                            data = list(
                              y = (cond != "sp"),
                              x = cbind(
                                t(assay(y)[j, , drop = FALSE]),
                                t(assay(x)[i, , drop = FALSE]))))
                    data.frame(
                      Motif = i,
                      Gene = j,
                      sample = s,
                      statadjusted = summary(a0)$coefficients[2, "t value"])
                  }))
            }))
      }))
# saveRDS(statadjusted, file = paste0("statadjusted.", tgtct, ".rds"))
statadjusted = readRDS(paste0("statadjusted.", tgtct, ".rds"))
```

Overlay statadjusted with corMGsigsig.
We discard motif-gene pairs where corMGsigsig = 0.

```{r}
s = "m154207"
s = "m167203"
s = "m168101"

library(dplyr)
clusterExport(cl, c("s", "corMGsigsig", "statadjusted",
                    "filter",
                    "select",
                    "slice_min",
                    "arrange",
                    "%>%"))
statadjustededges =
  # sapply(
  parSapply(cl = cl,
    colnames(corMGsigsig),
    function (tgtgene) {
      data =
        statadjusted %>%
        dplyr::filter(Gene == tgtgene) %>%
        dplyr::filter(sample == s) %>%
        dplyr::select(Motif, statadjusted)
      data$corMGsigsig = corMGsigsig[data$Motif, tgtgene]
      data$statadjustedpos =
        data$statadjusted *
        sign(median(data$statadjusted))
      statadjustedposlb =
        2.5 * quantile(data$statadjustedpos, 0.25) +
        (-1.5) * quantile(data$statadjustedpos, 0.75)
      dataupstreamMotif =
        data %>%
        dplyr::filter(statadjustedpos < statadjustedposlb) %>%
        dplyr::filter(statadjustedpos >= 0) %>%
        dplyr::filter(corMGsigsig > sqrt(0.5) * max(data$corMGsigsig) |
                        corMGsigsig < sqrt(0.5) * min(data$corMGsigsig)) %>%
        dplyr::slice_min(statadjustedpos, n = 10) %>%
        dplyr::arrange(statadjustedpos)
      x = rep(0, nrow(corMGsigsig))
      names(x) = row.names(corMGsigsig)
      if (nrow(dataupstreamMotif) > 0) {
        x[dataupstreamMotif$Motif] = 1
      }
      return(x)
    })

plot(log10(sort(rowSums(statadjustededges))))
plot(
  log10(rank(- rowSums(statadjustededges))),
  log10(rowSums(statadjustededges)))
head(sort(rowSums(statadjustededges), decreasing = TRUE), 20)
```

The motifs with higher degrees (ie hubs)
show larger differential expression under diet intervention.
However, the corresponding genes (mRNA) of the motif are not differentially expressed.

```{r}
plotdata = data.frame(
  statadjustededges = rowSums(statadjustededges))
foo = resultcomparedMotif[
  resultcomparedMotif$celltype == tgtct &
    resultcomparedMotif$sample == s, ]
plotdata$resultcomparedMotif =
  foo$statistic[match(sub("^Motif.", "", rownames(plotdata)), foo$genename)]
foo = resultcomparedGene[
  resultcomparedGene$celltype == tgtct &
    resultcomparedGene$sample == s, ]
plotdata$resultcomparedGene =
  foo$statistic[match(sub("^Motif.", "", rownames(plotdata)), foo$genename)]
ggplot(data = plotdata) +
  geom_point(
    aes(x = log1p(statadjustededges),
        y = resultcomparedMotif,
        col = resultcomparedGene)) +
  scale_color_gradient2(low = "blue", mid = "white", high = "red")
```

Clustering of motifs

```{r}
foo = statadjustededges[rowSums(statadjustededges) >= 200, ]
# heatmap(foo)
plot(
  hclust(dist(foo, method = "binary"), method = "average"),
  cex = 0.5)
```

## Detect mediator motifs by conditional analysis; mutual information

We want to detect the information flow (causality) "condition -> Motif i -> Gene j".
It doesn't matter whether there is bypass "condition -> Gene j".
In the language of entropy and mutual information, we detect by
mutual_info(Gene j; Motif i; condition) / entropy(Gene j) > 0.
Remark that
mutual_info(Gene j; Motif i; condition)
= mutual_info(Gene j; Motif i)
+ mutual_info(Gene j; condition)
- mutual_info(Gene j; Motif i, condition)
Instead of entropy and mutual information,
we actually use R2 (explained variance) of linear regression.

```{r}
x = matnrDEMotif
y = matnrDEGene
d = data.frame(
  m154207 = (matnrDEGene$Sample == "m154207"),
  m167203 = (matnrDEGene$Sample == "m167203"),
  m168101 = (matnrDEGene$Sample == "m168101"))
d = t(as.matrix(d) * 1)
```

```{r}
residualnull = rowSums( (assay(y) - rowMeans(assay(y)))^2 )

a1 = lm(t(assay(y)) ~ t(d))
R2diet = 1 - colSums(a1$residuals^2) / residualnull

cl = makeCluster(20)
clusterExport(cl, "assay")
clusterExport(cl, "x")
clusterExport(cl, "y")
clusterExport(cl, "d")
clusterExport(cl, "residualnull")
R2Motif =
  do.call(
    rbind,
    # lapply(
    parLapply(cl = cl,
              row.names(x),
              function (i) {
                a1 = lm(t(assay(y)) ~ assay(x)[i, ])
                1 - colSums(a1$residuals^2) / residualnull
              }))
R2Motifdiet =
  do.call(
    rbind,
    # lapply(
    parLapply(cl = cl,
              row.names(x),
              function (i) {
                print(i)
                a1 = lm(t(assay(y)) ~ cbind(assay(x)[i, ], t(d)))
                1 - colSums(a1$residuals^2) / residualnull
              }))
R2Motifdietmutual =
  R2Motif + matrix(R2diet, nrow = nrow(x), ncol = nrow(y), byrow = TRUE) - R2Motifdiet
R2Motifdietmutual[R2Motifdietmutual < 0] = 0
rownames(R2Motifdietmutual) = rownames(x)
# saveRDS(R2Motifdietmutual, paste0("R2Motifdietmutual.", tgtct, ".rds"))
R2Motifdietmutual = readRDS(paste0("R2Motifdietmutual.", tgtct, ".rds"))
```

```{r}
head(sort(rowMeans(R2Motifdietmutual), decreasing = TRUE))
head(sort(rowMeans(R2Motifdietmutual > 0), decreasing = TRUE))
```

# Multiple motifs-to-one gene analysis

## Compute regulatory motifs by using GENIE3

Include experimental condition as predictor.

```{r}
x = data.frame(
  m154207 = (matnrDEGene$Sample == "m154207"),
  m167203 = (matnrDEGene$Sample == "m167203"),
  m168101 = (matnrDEGene$Sample == "m168101"))
x = t(as.matrix(x) * 1)
```

For each gene, compute "regulatory" motifs.

```{r}
library(GENIE3)

set.seed(123)
weightMatrix = GENIE3(
  rbind(
    assay(matnrDEGene),
    assay(matnrDEMotif),
    x),
  targets = rownames(matnrDEGene),
  regulators = c(rownames(matnrDEMotif), rownames(x)),
  nCores = 22,
  verbose = TRUE)

# saveRDS(weightMatrix, file = paste0("GENIE3.",  tgtct, ".rds"))
weightMatrix = readRDS(paste0("GENIE3.",  tgtct, ".rds"))
```

Clean noise.

```{r}
plot(quantile(weightMatrix, seq(0, 1, 0.01)))
plot(quantile(weightMatrix, seq(1 - 1e-3, 1, 1e-5)))
plot(quantile(weightMatrix, seq(1 - 1e-4, 1, 1e-6)))

x = min(colQuantiles(weightMatrix, probs = 0.95))
weightMatrix = weightMatrix - x
weightMatrix[weightMatrix < 0] = 0

plot(sort(rowMeans(weightMatrix)))
weightMatrix = weightMatrix[rowMeans(weightMatrix) > 1e-4, ] # arbitrary
# stellate:    drops m167203 m168101 
# endothelial: drops m167203
# myelo:       drops m167203 m168101 
# T_NK:        drops all experimental conditions

# zero columns cause error in nmf
weightMatrix = weightMatrix[, colMaxs(weightMatrix) > 0]

plot(hclust(dist(weightMatrix)))
```

## Nonnegative matrix factorization of regulator-regulatee matrix

To choose the optimal value of r, first try 1; if not clear try 2.
1. (Hutchins2008) suggested to choose the first value where the RSS curve presents an inflection point, and (Frigyesi2008) considered the value of r after which the decrease in the RSS becomes lower than the decrease of the RSS obtained from random data.
2. (Brunet2004) proposed to take the value of r after which the cophenetic coefficient starts to drop steeply.

```{r}
library(NMF)

gc()
estim.r = nmf(weightMatrix,
              rank = 2:6,
              nrun = 30, # 10 30
              seed = 123456,
              .opt = 'vP4') # P5 error
# plot(estim.r)

set.seed(123456)
V.random = randomize(weightMatrix)
gc()
estim.r.random = nmf(V.random,
                     rank = 2:6,
                     nrun = 30, # 10 30
                     seed = 123456,
                     .opt = 'vP4')
# plot(estim.r, estim.r.random)
rm(V.random)

r = 4 # hepato stellate myelo
r = 3 # endothelial T_NK

# res.nndsvd = nmf(weightMatrix,
#                  rank = r,
#                  seed = 'nndsvd')

gc()
res = nmf(weightMatrix,
          rank = r,
          nrun = 100, # 10 100
          seed = 123456,
          .opt = 'vP4')
summary(res, target = weightMatrix)
# saveRDS(res, file = paste0("GENIE3.NMF.rank", r, ".", tgtct, ".rds"))
res = readRDS(paste0("GENIE3.NMF.rank", r, ".", tgtct, ".rds"))

basismap(res)
# coefmap(res)
summary(basis(res))
summary(t(coefficients(res)))
basis(res)["Motif.Hnf4g", ]
```

In `summary(t(coefficients(res)))`, one factor has large median and 3rd quantile.
Does it correspond to "all of the remaining genes"?
The basis for the factor includes Motif.Hnf4g.
We set this factor as the last one in moduleindex.
Motif.Hnf4g is up in m154207 (HFD4w) and down in m168101 (washout).  Why??

This setting is for visualization.
We set the factor(s) with significant GSEA in the beginning (see below).

```{r}
# hepato
moduleindex = c(4, 2, 1, 3)
# stellate
moduleindex = c(1, 2, 4, 3)
# endothelial
moduleindex = c(3, 1, 2)
# myelo
moduleindex = c(3, 1, 2, 4)
# T_NK
moduleindex = c(2, 1, 3)
```

Draw heatmap for regulation of genes by motifs.

```{r}
topMotiflist = lapply(
  moduleindex,
  function (i) {
    x = sort(basis(res)[, i], decreasing = TRUE)
    x = x[! names(x) %in% grep("^m", names(x), value = TRUE)]
    x = x[x > max(x) / 2]
    return(head(names(x), 5))
  })
topMotif = union(do.call(c, topMotiflist), c())

topGenelist = lapply(
  moduleindex,
  function (i) {
    x = sort(coef(res)[i, ], decreasing = TRUE)
    x = x[x > max(x) / 2]
    return(head(names(x), 5))
  })
topGene = union(do.call(c, topGenelist), c())

weightMatrix = readRDS(paste0("GENIE3.",  tgtct, ".rds"))
x = t(weightMatrix[topMotif, topGene])
rownames(x) = sub("^Gene.", "", rownames(x))
colnames(x) = toupper(sub("^Motif.", "", colnames(x)))

aC = as.data.frame(basis(res)[topMotif, moduleindex])
names(aC) = paste0("Motif.M", 1:ncol(aC))
aR = as.data.frame(t(coef(res)[moduleindex, topGene]))
names(aR) = paste0("Gene.M", 1:ncol(aR))
NMF::aheatmap(
  x,
  color = c("white", "black"),
  Rowv = NA,
  Colv = NA,
  annCol = aC,
  annRow = aR,
  annColors = rep(list(c("white", "black")), dim(res)[3] * 2),
  main = tgtct,
  treeheight = 0,
  filename = "NMF.heatmap.pdf", width = 5, height = 5)
```

## Gene set enrichment analysis for genes belonging to factors (modules)

Load `gslists` from `9_GSEA.Rmd`.

```{r}
x = as.data.frame(t(coef(res)))
row.names(x) = sub("^Gene.", "", row.names(x))
set.seed(123)
result =
  lapply(
    1:ncol(x),
    function (j) {
      print(j)
      lapply(
        gslists,
        function (gslist) {
          gslistresult =
            do.call(
              rbind,
              lapply(
                gslist,
                function (gs) {
                  ings = (row.names(x) %in% gs)
                  if (min(sum(ings), sum(! ings)) < 5) {
                    return(data.frame(statistic = NA, p.value = NA))
                  } else {
                    return(
                      as.data.frame(
                        t.test(
                          x[ings, j],
                          x[! ings, j],
                          alternative = "greater",
                          var.equal = TRUE)[c("statistic", "p.value")]))
                  }}))
          statisticnull =
            sapply(
              1:100,
              function (i) {
                sapply(
                  gslist,
                  function (gs) {
                    ings = (row.names(x) %in% gs)[sample(nrow(x))]
                    if (min(sum(ings), sum(! ings)) < 5) {
                      return(NA)
                    } else {
                      return(
                        t.test(
                          x[ings, j],
                          x[! ings, j],
                          alternative = "greater",
                          var.equal = TRUE)$statistic)
                    }})
              })
          statisticnull = colMaxs(statisticnull, na.rm = TRUE)
          gslistresult$fwe =
            sapply(
              gslistresult$statistic,
              function (s) { mean(s <= statisticnull) })
          return(gslistresult)
        })
    })
# saveRDS(result, file = paste0("GENIE3.NMF.rank", r, ".", tgtct, ".GSEA.rds"))
result = readRDS(paste0("GENIE3.NMF.rank", r, ".", tgtct, ".GSEA.rds"))
```

## Inspect enriched gene sets

When there are too many gene sets attaining family-wise error rate (fwe) < 0.05,
visualize and choose representatives by using Cytoscape:
1. Apps > EnrichmentMap. Import GMT file `foo.gmt`
2. Node Table. Import `foo.txt` and add column log10P
3. Style > Fill Color > Map. Column = log10Ppadog. Mapping Type = Continuous Mapping
4. [Optional] Apps > clusterMaker > MCODE Cluster. Create new clustered network
5. Layout > yFiles Radial Layout

Generate files to be loaded to Cytoscape.

```{r}
j = 1
data = result[[j]]
data = data[c(1:7, 9)]
data = do.call(rbind, data)
data$Name = rownames(data)
datafwe005 = data[!is.na(data$fwe) & data$fwe < 0.05, ]
datafwe005$log10P = log10(datafwe005$p.value)
datafwe005 = datafwe005[order(datafwe005$p.value), ]
datafwe005
datafwe005[order(datafwe005$Name), ]
datafwe005$Name2 = sub("[^.]*\\.", "", datafwe005$Name, perl = TRUE)
write.table(
  datafwe005[, c("Name2", "log10P")],
  file = "foo.txt",
  row.names = FALSE,
  col.names = TRUE,
  sep = "\t",
  quote = FALSE)

output = do.call(c, gslists)
output = output[datafwe005$Name]
output = lapply(output, function (x) { paste0(x, collapse = "\t") })
x = names(output)
x = sub("[^.]*\\.", "", x, perl = TRUE)
output = paste(
  x,
  sub("%.*", "", x),
  unlist(output),
  sep = "\t")
cat(output, file = "foo.gmt", sep = "\n")
```

Gene sets of interest are handpicked and sorted by biological process.

```{r}
# * indicates "not significant in diet comparison"
dbnamegsname = rbind(
  data.frame(dbname = 'GOBP', gsname = 'GOBP_STEROID_METABOLIC_PROCESS%%M16758'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_REGULATION_OF_CHOLESTEROL_BIOSYNTHESIS_BY_SREBP_SREBF%%M27001'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_LIPID_STORAGE%%M15541'),
  data.frame(dbname = 'KEGG', gsname = 'KEGG_PPAR_SIGNALING_PATHWAY%%M13088'),
  data.frame(dbname = 'H', gsname = 'HALLMARK_XENOBIOTIC_METABOLISM%%M5934'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608'),
  
  data.frame(dbname = 'H', gsname = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB%%M5890'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_CYTOKINE_PRODUCTION%%M13156'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_RESPONSE_TO_CYTOKINE%%M15783'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_INTERLEUKIN_1_SIGNALING%%M27895'),
  data.frame(dbname = 'H', gsname = 'HALLMARK_IL2_STAT5_SIGNALING%%M5947'), # *
  data.frame(dbname = 'H', gsname = 'HALLMARK_IL6_JAK_STAT3_SIGNALING%%M5897'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_INTERLEUKIN_10_SIGNALING%%M27605'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_INFLAMMASOMES%%M1072'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_ADAPTIVE_IMMUNE_RESPONSE%%M13847'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_CREATION_OF_C4_AND_C2_ACTIVATORS%%M1078'), # *
  data.frame(dbname = 'GOBP', gsname = 'GOBP_MYELOID_LEUKOCYTE_ACTIVATION%%M12762'),
  data.frame(dbname = 'KEGG', gsname = 'KEGG_HEMATOPOIETIC_CELL_LINEAGE%%M6856'), # *
  data.frame(dbname = 'WIKIPATHWAYS', gsname = 'WP_ONCOSTATIN_M_SIGNALING_PATHWAY%%M39562'),
  
  data.frame(dbname = 'KEGG', gsname = 'KEGG_APOPTOSIS%%M8492'),
  data.frame(dbname = 'H', gsname = 'HALLMARK_APOPTOSIS%%M5902'), # *
  
  data.frame(dbname = 'GOBP', gsname = 'GOBP_ACTIN_FILAMENT_BASED_PROCESS%%M9082'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_CELL_MIGRATION%%M40389'),
  # stellate
  data.frame(dbname ="REACTOME", gsname = "REACTOME_EXTRACELLULAR_MATRIX_ORGANIZATION%%M610"), # *
  data.frame(dbname = 'GOBP', gsname = 'GOBP_SEMAPHORIN_PLEXIN_SIGNALING_PATHWAY%%M15378'), # *
  data.frame(dbname = 'H', gsname = 'HALLMARK_TGF_BETA_SIGNALING%%M5896'), # *
  # endothelial
  data.frame(dbname = 'WIKIPATHWAYS', gsname = 'WP_VEGFAVEGFR2_SIGNALING_PATHWAY%%M39729'), # *
  
  data.frame(dbname = 'H', gsname = 'HALLMARK_MITOTIC_SPINDLE%%M5893'), # *
  data.frame(dbname = 'H', gsname = 'HALLMARK_KRAS_SIGNALING_UP%%M5953'), # *
  data.frame(dbname = 'H', gsname = 'HALLMARK_PI3K_AKT_MTOR_SIGNALING%%M5923'), # *

  data.frame(dbname = 'WIKIPATHWAYS', gsname = 'WP_FARNESOID_X_RECEPTOR_PATHWAY%%M39411'), # *
  data.frame(dbname = 'GOBP', gsname = 'GOBP_GLUTAMINE_FAMILY_AMINO_ACID_BIOSYNTHETIC_PROCESS%%M10295') # *
)
```

Visualize GSEA results.

```{r}
dataplot = lapply(result[moduleindex], function (x) do.call(rbind, x))
dataplot = lapply(dataplot, function (x) x[paste0(dbnamegsname$dbname, ".", dbnamegsname$gsname), ])

x = do.call(cbind, lapply(dataplot, function (x) x[, "p.value", drop = FALSE]))
names(x) =  paste0("Module ", 1:ncol(x))
x$gsname = factor(rownames(x), levels = rownames(x))
dataplot.P = x
x = do.call(cbind, lapply(dataplot, function (x) x[, "fwe", drop = FALSE]))
names(x) =  paste0("Module ", 1:ncol(x))
significant = (rowSums(is.na(x)) == 0) & (rowMins(as.matrix(x), na.rm = TRUE) < 0.05)
x$gsname = factor(rownames(x), levels = rownames(x))
dataplot.fwe = x
dataplot.P = dataplot.P[significant, , drop = FALSE]
dataplot.fwe = dataplot.fwe[significant, , drop = FALSE]

dataplot.P = tidyr::pivot_longer(dataplot.P,
                                 cols = matches("^Module \\d+", perl = TRUE),
                                 names_to = "factor",
                                 values_to = "P")
dataplot.fwe = tidyr::pivot_longer(dataplot.fwe,
                                   cols = matches("^Module \\d+", perl = TRUE),
                                   names_to = "factor",
                                   values_to = "fwe")
dataplot =
  dplyr::left_join(dataplot.P, dataplot.fwe, by = c("gsname", "factor"))

p1 =
  ggplot(dataplot,
         aes(x = gsname,
             y = - log10(P))) +
  geom_bar(stat = "identity",
           aes(fill = (fwe < 0.05))) +
  scale_fill_manual(values = c("gray50", "black")) +
  guides(fill = "none") +
  facet_grid(rows = vars(factor)) +
  theme(axis.text.x = element_text(angle = 90,
                                   hjust = 1,
                                   vjust = 0.5,
                                   size = rel(0.4))) +
  labs(title = tgtct,
       x = NULL)
show(p1)
# ggsave(p1, filename = "modulescore_GSEA.Gene.pdf", width = 3.15, height = 5.65)
```

## Visualize NMF VarianceImportance vs differential expression

```{r}
# Run this for Motif
x = as.data.frame(basis(res))
x = x[, moduleindex, drop = FALSE]
names(x) = paste0("Module ", 1:ncol(x))
x$genename = row.names(x)
x = tidyr::pivot_longer(x,
                        cols = matches("^Module \\d+", perl = TRUE),
                        names_to = "factor",
                        values_to = "score")
x$intop = FALSE
for (i in 1:length(topMotiflist)) {
  x$intop[(x$genename %in% topMotiflist[[i]]) &
            (x$factor == paste0("Module ", i))] = TRUE
}
x$genename = sub("^Motif.", "", x$genename)
dataplot = resultcomparedMotif %>%
  dplyr::filter(celltype == tgtct)

# Run this for Gene
x = as.data.frame(t(coef(res)))
x = x[, moduleindex, drop = FALSE]
names(x) = paste0("Module ", 1:ncol(x))
x$genename = row.names(x)
x = tidyr::pivot_longer(x,
                        cols = matches("^Module \\d+", perl = TRUE),
                        names_to = "factor",
                        values_to = "score")
x$intop = FALSE
for (i in 1:length(topGenelist)) {
  x$intop[(x$genename %in% topGenelist[[i]]) &
            (x$factor == paste0("Module ", i))] = TRUE
}
x$genename = sub("^Gene.", "", x$genename)
dataplot = resultcomparedGene %>%
  dplyr::filter(celltype == tgtct)

dataplot = dplyr::inner_join(dataplot, x, by = "genename")
p1 =
  ggplot(data = dataplot,
         aes(x = statistic,
             y = score)) +
  geom_point(aes(color = intop), size = 0.3) +
  scale_color_manual(values = c("black", "red"), guide = "none") +
  facet_grid(rows = vars(factor),
             cols = vars(sample),
             scales = "free_y") +
  labs(x = "Differential expression by diet [Z statistic]",
       y = "Module score") +
  theme(axis.text.x = element_text(size = rel(0.75)),
        axis.text.y = element_text(size = rel(0.75))) +
  theme(panel.spacing.y = unit(1, "lines"))
ggsave(p1, filename = "modulescore_DE.pdf", width = 3.5, height = 4)
```

Although all components could be associated with diet,
quantify to inspect which component is strongly associated with differential gene expression.

```{r}
library(dplyr)

x = as.data.frame(t(coef(res)))
x = x[, moduleindex, drop = FALSE]
names(x) = paste0("Module ", 1:ncol(x))
x$genename = sub("^Gene.", "", row.names(x))
x = tidyr::pivot_longer(x,
                        cols = matches("^Module \\d+", perl = TRUE),
                        names_to = "factor",
                        values_to = "score")
data = resultcomparedGene %>%
  dplyr::filter(celltype == tgtct)
data = dplyr::inner_join(data, x, by = "genename")

data %>%
  dplyr::group_by(factor, sample) %>%
  dplyr::summarize(
    statpos = summary(lm(statistic^2 ~ score + 0,
                         weights = score^2,
                         subset = statistic > 0))$coefficients[3],
    statneg = summary(lm(statistic^2 ~ score + 0,
                         weights = score^2,
                         subset = statistic < 0))$coefficients[3],
    .groups = "drop")
```

## SVD based on weighting by NMF factors (modules)

GENIE3 and NMF quantify the importance of genes/motifs as explained variance.
To infer the "directionality", we perform SVD by incorporating the variance as weight.
GENIE3 is a regression: each gene ~ motifs.
SVD and PCA are for extracting correlation.
Although the two concepts differ, it seems to work for assigning directionality.
We might say that genes/motifs highlighted in both approaches are robustly important.

Compute weight.

```{r}
x = t(coef(res))
x = x %*% diag(1 / colMeans(x))
x = sqrt(x) # convert from var to sd

wGene = x[match(rownames(matnrDEGene), row.names(x)), ]
wGene[is.na(wGene)] = 0
rownames(wGene) = rownames(matnrDEGene)

x = basis(res)
x = x %*% diag(1 / colMeans(x))
x = sqrt(x) # convert from var to sd

wMotif = x[match(rownames(matnrDEMotif), row.names(x)), ]
wMotif[is.na(wMotif)] = 0
rownames(wMotif) = rownames(matnrDEMotif)
```

Weighted SVD.

```{r}
identical(colnames(matnrDEGene), colnames(matnrDEMotif))

XGene = assay(matnrDEGene)
XGene = XGene - rowMeans(XGene)
XGene = XGene / rowSds(XGene)

XMotif = assay(matnrDEMotif)
XMotif = XMotif - rowMeans(XMotif)
XMotif = XMotif / rowSds(XMotif)

set.seed(123)
sXgslist = lapply(
  1:dim(res)[3],
  function (i) {
    irlba::irlba(rbind(XGene * wGene[, i], XMotif * wMotif[, i]))
  })

# For each factor, check if first element is much larger than the remaining.
# If not, the gene set is heterogeneous, which could be OK.
lapply(
  sXgslist,
  function (x) x$d)
```

SVD with cells permuted between motif and genes.
Check if the regulator motifs are correlated with regulatee genes.

```{r}
set.seed(123)
sXgsnull = sapply(
  1:dim(res)[3],
  function (i) { # factor
    print(i)
    sapply(
      1:100,
      function (j) { # permutation trial
        x = irlba::irlba(rbind(XGene * wGene[, i],
                               XMotif[, sample(ncol(XMotif))] * wMotif[, i]))
        data.frame(d1 = x$d[1])
      })
  },
  simplify = "array")

# For each NMF factor, check if first SVD component attains P < 0.05
lapply(
  1:dim(res)[3],
  function (i) {
    mean(as.numeric(sXgsnull[, i]) > sXgslist[[i]]$d[1])
  })
```

This setting is for visualization.
SVD direction for plotting.

```{r}
# hepato
sXgssign = c(1, -1, 1, 1)
# stellate
sXgssign = c(-1, -1, 1, 1)
# endothelial
sXgssign = c(-1, -1, -1)
# myelo
sXgssign = c(1, -1, 1, 1)
# T_NK
sXgssign = c(1, -1, 1)
```

Major Genes/Motifs for each NMF factor.

```{r}
dataplot = do.call(
  rbind,
  lapply(
    1:dim(res)[3],
    function (i) {
      x = (XGene / sqrt(ncol(XGene) - 1)) %*% sXgslist[[i]]$v[, 1]
      x = x[, 1]
      x = sort(x * sXgssign[i])
      x = c(head(x, 5), tail(x, 5))
      dataplot = data.frame(
        order = 1:length(x),
        score = x,
        name = sub("^Gene.", "", names(x)),
        type = "Gene",
        module = paste0("Module ", which(moduleindex == i)))
      
      x = (XMotif / sqrt(ncol(XMotif) - 1)) %*% sXgslist[[i]]$v[, 1]
      x = x[, 1]
      x = sort(x * sXgssign[i])
      x = c(head(x, 5), tail(x, 5))
      dataplot = rbind(
        dataplot,
        data.frame(
          order = 1:length(x),
          score = x,
          name = toupper(sub("^Motif.", "", names(x))),
          type = "Motif",
          module = paste0("Module ", which(moduleindex == i))))
      
      return(dataplot)
    }))

dataplot$type = factor(dataplot$type, levels = c("Motif", "Gene"))
p1 =
  ggplot(data = dataplot,
         aes(x = order,
             y = score)) +
  geom_col() +
  geom_text(aes(label = name, y = -0.03 * sign(score), hjust = -0.5 * sign(score) + 0.5), angle = -90) +
  theme(
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    axis.title.x = element_blank()) +
  labs(y = "Correlation with module expression") +
  facet_grid(rows = vars(module), cols = vars(type))
show(p1)
ggsave(p1,
       filename = paste0("GENIE3.NMF.rank", dim(res)[3], ".", tgtct, ".pdf"),
       width = 5, height = 7)
```

Relative expression level by diets, for each NMF factor.

```{r}
A = proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)]
A = as.factor(A)

dataplot =
  do.call(
    rbind,
    lapply(
      1:dim(res)[3],
      function (i) {
        a0 = lm(
          sXgslist[[i]]$v[, 1] * sqrt(nrow(sXgslist[[i]]$v)) * sXgssign[i] ~
            0 + A)
        x = summary(a0)$coefficients[, 1:2]
        x = as.data.frame(x)
        x$diet = sub("^A", "", rownames(x))
        x$Module = paste0("Module ", which(moduleindex == i))
        return(x)
      }))
p1 =
  ggplot(data = dataplot,
         aes(x = diet,
             y = Estimate)) +
  geom_linerange(
    aes(ymin = Estimate - `Std. Error`,
        ymax = Estimate + `Std. Error`)) +
  geom_col() +
  labs(x = NULL,
       y = "Relative expression level of module") +
  facet_grid(rows = vars(Module))
ggsave(filename = paste0(tgtct, ".modulescore_diet.Gene.pdf"), p1,
       height = 3.5, width = 3)

dataplot =
  do.call(
    rbind,
    lapply(
      1:dim(res)[3],
      function (i) {
        data.frame(
          diet = A,
          expression = sXgslist[[i]]$v[, 1] * sqrt(nrow(sXgslist[[i]]$v)) * sXgssign[i],
          Module = paste0("Module ", which(moduleindex == i)))
      }))
p1 =
  ggplot(data = dataplot,
         aes(x = diet,
             y = expression)) +
  geom_violin() +
  geom_boxplot(width = 0.1, fill = "black", outlier.color = NA) +
  stat_summary(fun = median, geom = "point", fill = "white", shape = 21, size = 1.7) +
  labs(x = NULL,
       y = "Module expression in single cells") +
  facet_grid(rows = vars(Module))
ggsave(filename = paste0(tgtct, ".modulescore_diet.geom_violoin.pdf"), p1,
       height = 3.5, width = 3)
```

# Multiple genes-to-one gene analysis

Include experimental condition as predictor.

```{r}
x = data.frame(
  m154207 = (matnrDEGene$Sample == "m154207"),
  m167203 = (matnrDEGene$Sample == "m167203"),
  m168101 = (matnrDEGene$Sample == "m168101"))
x = t(as.matrix(x) * 1)
```

Gene-gene regulation

```{r}
library(GENIE3)

set.seed(123)
weightMatrix = GENIE3(
  rbind(
    assay(matnrDEGene),
    x),
  targets = rownames(matnrDEGene),
  regulators = c(rownames(matnrDEGene), rownames(x)),
  nCores = 22,
  verbose = TRUE)

# saveRDS(weightMatrix, file = paste0("GENIE3_GeneGene.",  tgtct, ".rds"))
weightMatrix = readRDS(paste0("GENIE3_GeneGene.",  tgtct, ".rds"))
rownames(weightMatrix) = sub("^Gene.", "", rownames(weightMatrix))
colnames(weightMatrix) = sub("^Gene.", "", colnames(weightMatrix))
```

Clean noise.

```{r}
plot(quantile(weightMatrix, seq(0, 1, 0.01)))
plot(quantile(weightMatrix, seq(1 - 1e-3, 1, 1e-5)))
plot(quantile(weightMatrix, seq(1 - 1e-4, 1, 1e-6)))

x = median(colQuantiles(weightMatrix, probs = 0.95))
weightMatrix = weightMatrix - x
weightMatrix[weightMatrix < 0] = 0

plot(sort(rowMeans(weightMatrix)))
```

Find key genes for a target gene set.
Load `gslists` from `9_GSEA.Rmd`.

```{r}
dbname = 'REACTOME'; gsname = 'REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227'
dbname = 'GOBP'; gsname = 'GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829'
dbname = 'KEGG'; gsname = 'KEGG_PPAR_SIGNALING_PATHWAY%%M13088'
dbname = 'H'; gsname = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB%%M5890'
dbname = 'KEGG'; gsname = 'KEGG_APOPTOSIS%%M8492'
dbname = 'GOBP'; gsname = 'GOBP_CELL_MIGRATION%%M40389'
dbname = 'REACTOME'; gsname = 'REACTOME_EXTRACELLULAR_MATRIX_ORGANIZATION%%M610'
dbname = 'GOBP'; gsname = 'GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608'
gs = gslists[[ dbname ]][[ gsname ]]
```

```{r}
data = data.frame(
  genename = rownames(weightMatrix),
  score = rowSums(weightMatrix[, colnames(weightMatrix) %in% gs])
)
data = dplyr::left_join(data,
                        as.data.frame(geneAnnotation$genes),
                        by = c("genename" = "symbol"))
t.test(data$score[data$genename %in% gs], data$score[! data$genename %in% gs])
tail(data[order(data$score), ], 20)
```

The enrichment is weak.
Was `nrow(matnrDEGene)` predictors too many for GENIE3?

# Activity score and co-regulation of a gene set

For a given gene set, the following might be confused but are different:
1. Genes that are differentially expressed among conditions
2. "Core" genes in co-regulation, here defined as co-regulated with other genes in the gene set

## Define gene set

Load `gslists` from `9_GSEA.Rmd`.

```{r}
# hepato
dbname = 'GOBP'; gsname = 'GOBP_STEROID_METABOLIC_PROCESS%%M16758'
dbname = 'REACTOME'; gsname = 'REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227'
dbname = 'GOBP'; gsname = 'GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829'
dbname = 'KEGG'; gsname = 'KEGG_PPAR_SIGNALING_PATHWAY%%M13088' # failed check
dbname = 'KEGG'; gsname = 'KEGG_APOPTOSIS%%M8492'
dbname = 'GOBP'; gsname = 'GOBP_APOPTOTIC_PROCESS%%M34075'
dbname = 'GOBP'; gsname = 'GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608'
dbname = 'WIKIPATHWAYS'; gsname = 'WP_FARNESOID_X_RECEPTOR_PATHWAY%%M39411'

# stellate
dbname = 'GOBP'; gsname = 'GOBP_SEMAPHORIN_PLEXIN_SIGNALING_PATHWAY%%M15378'
dbname = 'REACTOME'; gsname = 'REACTOME_EXTRACELLULAR_MATRIX_ORGANIZATION%%M610' # failed check
dbname = 'GOBP'; gsname = 'GOBP_ACTIN_FILAMENT_BASED_PROCESS%%M9082'

# myelo
dbname = 'REACTOME'; gsname = 'REACTOME_CREATION_OF_C4_AND_C2_ACTIVATORS%%M1078'

# hepato endothelial myelo
dbname = 'H'; gsname = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB%%M5890'
dbname = 'GOBP'; gsname = 'GOBP_RESPONSE_TO_CYTOKINE%%M15783' # myelo failed check
dbname = 'GOBP'; gsname = 'GOBP_ADAPTIVE_IMMUNE_RESPONSE%%M13847' # myelo failed check

# hepato stellate myelo
dbname = 'GOBP'; gsname = 'GOBP_CELL_MIGRATION%%M40389' # stellate failed check

# hepato stellate myelo T_NK
dbname = 'KEGG'; gsname = 'KEGG_TGF_BETA_SIGNALING_PATHWAY%%M2642' # hepato & stellate failed check

# endothelial myelo
dbname = 'WIKIPATHWAYS'; gsname = 'WP_VEGFAVEGFR2_SIGNALING_PATHWAY%%M39729'

gs = gslists[[ dbname ]][[ gsname ]]
```

Zonation genes from literature as a gene set

```{r}
gsname = "ZONATION"
x = read.table(
  # "zonation_hepatocyte_mouse_10.1038_nature21065_TableS3_q001.txt", # too many; PC2 also large
  "zonation_hepatocyte_mouse_10.1038_nature21065_TableS3_q1e-6.txt",
  # "zonation_stellate_mouse_10.1016_j.celrep.2019.10.024_TableS1.txt", # not significant
  # "zonation_endothelial_mouse_10.1038_nbt.4231_TableS5_q02.txt", # not significant
  # "zonation_endothelial_mouse_10.1038_nbt.4231_TableS5_q001.txt", # not significant
  # "zonation_endothelial_mouse_10.1038_nbt.4231_TableS5_q1e-6.txt", # not significant
  header = FALSE)$V1
# Convert to rat gene symbol
attach("~/human/publicrat/homologs/mouse_to_rat_homologs.Rda")
x = mouse_to_rat_homologs$RGD.symbol[
  match(
    tolower(x),
    tolower(mouse_to_rat_homologs$NCBI.gene..formerly.Entrezgene..accession))]
gs = x[(! is.na(x)) & (x != "")]
```

Load STRING protein-protein interaction with gs

```{r}
string = data.table::fread(
  file = "~/human/publicrat/STRING/10116.protein.links.name.txt",
  sep ="\t")
string = string[string$protein1 != string$protein2, ]
string = string[string$protein2 %in% gs, ]
string = string %>%
  # dplyr::filter(combined_score >= 0.4) %>%
  dplyr::select(-c("protein2")) %>%
  dplyr::group_by(protein1) %>%
  dplyr::summarize(ppinteractionwithgs = sum(combined_score))

t.test(string$ppinteractionwithgs[string$protein1 %in% gs], 
       string$ppinteractionwithgs[! string$protein1 %in% gs])
```

## Compute gene set activity score

In the code block below, check if the genes in `gs` are co-regulated, more than randomly chosen genes.
If so, the "average expression" is defined as the gene set activity score, `gsactivity`.
`gsactivity` might or might not be differentially expressed between diet conditions.

Use `matnrDEGene` and `matnrDEMotif`, which should include less noise.
When `gsactivity` is not differentially expressed between diet conditions,
instead use `matnrGene` and `matnrMotif`;
specifically for GOBP_SEMAPHORIN_PLEXIN_SIGNALING_PATHWAY and ZONATION.

```{r}
# For DE genes/motifs
identical(colnames(matnrDEGene), colnames(matnrDEMotif))
A = proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)]

# For all genes/motifs
# identical(colnames(matnrGene), colnames(matnrMotif))
# A = proj6$spdietcombined[match(colnames(matnrGene), proj6$cellNames)]

A = as.factor(A)
```

Make weight by gs.

```{r}
# For DE genes/motifs
wGene = (rownames(matnrDEGene) %in% paste0("Gene.", gs)) * 1
names(wGene) = rownames(matnrDEGene)
wMotif = (rownames(matnrDEMotif) %in% paste0("Motif.", gs)) * 1
names(wMotif) = rownames(matnrDEMotif)

# For all genes/motifs
# wGene = (rownames(matnrGene) %in% paste0("Gene.", gs)) * 1
# names(wGene) = rownames(matnrGene)
# wMotif = (rownames(matnrMotif) %in% paste0("Motif.", gs)) * 1
# names(wMotif) = rownames(matnrMotif)
```

Weighted SVD.

```{r}
# For DE genes/motifs
XGene = assay(matnrDEGene)
XMotif = assay(matnrDEMotif)

# For all genes/motifs
# XGene = assay(matnrGene)
# XMotif = assay(matnrMotif)

XGene = XGene - rowMeans(XGene)
XGene = XGene / rowSds(XGene)
XMotif = XMotif - rowMeans(XMotif)
XMotif = XMotif / rowSds(XMotif)

set.seed(123)
sXgs = irlba::irlba(rbind(XGene * wGene, XMotif * wMotif))

# Check if first element is much larger than the remaining.
# If not, the gene set is heterogeneous, and discarded.
sXgs$d
```

SVD with permuted weight.
Check if the regulator motifs/genes are correlated more than randomly picked motifs/genes.

```{r}
set.seed(123)
sXgsnull = 
  sapply(
    1:10, # 1:100,
    function (j) { # permutation trial
      x = irlba::irlba(rbind(XGene * wGene[sample(length(wGene))],
                             XMotif * wMotif[sample(length(wMotif))]))
      x$d[1]
    })

# Check if first SVD component attains P < 0.05
mean(sXgsnull > sXgs$d[1])
```

Define gene set activity score.

```{r}
sXgssign = 1 # 1 or -1
gsactivity = sXgs$v[, 1] * sqrt(nrow(sXgs$v)) * sXgssign
```

Compare `gsactivity` between diets.

```{r}
a0 = lm(gsactivity ~ 0 + A)
dataplot = summary(a0)$coefficients[, 1:2]
dataplot = as.data.frame(dataplot)
dataplot$diet = sub("^A", "", rownames(dataplot))
p1 =
  ggplot(data = dataplot,
         aes(x = diet,
             y = Estimate)) +
  geom_linerange(
    aes(ymin = Estimate - `Std. Error`,
        ymax = Estimate + `Std. Error`)) +
  geom_col() +
  labs(x = NULL,
       y = "Relative expression level of GS")
ggsave(filename = paste0(tgtct, ".", gsname, ".diet.pdf"), p1,
       height = 3.5, width = 3)

dataplot =
  data.frame(
    diet = A,
    expression = gsactivity)
p1 =
  ggplot(data = dataplot,
         aes(x = diet,
             y = expression)) +
  geom_violin() +
  geom_boxplot(width = 0.1, fill = "black", outlier.color = NA) +
  stat_summary(fun = median, geom = "point", fill = "white", shape = 21, size = 1.7) +
  labs(x = NULL,
       y = "GS expression of single cells")
ggsave(filename = paste0(tgtct, ".", gsname, ".diet.geom_violoin.pdf"), p1,
       height = 1, width = 3)


library(pROC)
for (x in setdiff(A, "sp")) {
  print(x)
  A2level = as.character(A)
  A2level[A2level != "sp" & A2level != x] = NA
  A2level = factor(A2level, levels = c("sp", x))
  print(auc(roc(A2level,  gsactivity)))
}
```

## Core genes as those central in co-regulation and protein-protein interaction

Genes central in co-regulation should have strong correlation with `gsactivity`.

Combine with ppinteractionwithgs
Among genes/motifs with large abs(score), if many have high ppinteractionwithgs, this approach is promising.
If most have low ppinteractionwithgs, this approach is not working.

If a few genes have similar and extreme score, and the genes are clustered on chromosome,
the co-regulation can be an artifact; it can be genuine, but is difficult to prove in snATAC-seq.

```{r}
dataplot = data.frame(
  score = rbind(XGene, XMotif) %*% gsactivity / sqrt(nrow(sXgs$v)) / sqrt(nrow(sXgs$v) - 1),
  name = c(sub("Gene.", "", rownames(XGene)),
           toupper(sub("Motif.", "", rownames(XMotif)))),
  genename = c(sub("Gene.", "", rownames(XGene)),
               sub("Motif.", "", rownames(XMotif)))
)

dataplot$ppinteractionwithgs =
  string$ppinteractionwithgs[
    match(dataplot$genename, string$protein1)]
dataplot$ppinteractionwithgs[
  is.na(dataplot$ppinteractionwithgs)] = 0

dataplot$interact = "Low"
dataplot$interact[
  dataplot$ppinteractionwithgs >
    quantile(dataplot$ppinteractionwithgs, 0.95)] = "High"
dataplot$geneset2 = "Genes not in GS"
dataplot$geneset2[dataplot$genename %in% gs] = "Genes in GS"
sum(dataplot$genename %in% gs)
p1 =
  ggplot(
    data = dataplot,
    aes(x = score,
        y = ppinteractionwithgs)) +
  geom_point(aes(color = interact),
             size = 0.5) +
  scale_x_continuous(breaks = seq(-12, 12, 4)/10) +
  scale_color_manual(values = c("Red", "Blue")) +
  geom_text(data = dataplot[abs(dataplot$score) > 0.3 & # 0.4 if not hepato
                              dataplot$interact == "High", ],
            aes(x = score,
                y = ppinteractionwithgs,
                label = name),
            vjust = 0,
            size = 2) +
  facet_grid(rows = vars(geneset2)) +
  labs(x = "Correlation with GS activity score",
       y = "Total protein-protein interactions with GS",
       title = paste0(gsname, "\n", tgtct))
ggsave(p1, filename = paste0("ppinteractionwithgs.", tgtct, ".", gsname, ".pdf"),
       height = 4, width = 5)
```

## Co-regulation

To find "core" genes in co-regulation, we analyze co-regulation within diet/condition.
Use `matnrDEGene`, which should include less noise.

```{r}
# X = assay(matnrGene)
# A = proj6$spdietcombined[match(colnames(matnrGene), proj6$cellNames)]
X = assay(matnrDEGene)
A = proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)]

X = X - rowMeans(X)
A = as.factor(A)
Alist = lapply(unique(A), function(a) which(A == a))

# Y = within environment dispersion
# Z = between environment dispersion
Z = X * 0
for (ind in Alist) {
  m = rowMeans(X[, ind])
  Z[, ind] = m
  rm(m)
}
Y = X - Z
Y = Y / rowSds(Y)

Ygs = Y[rownames(Y) %in% paste0("Gene.", gs), ]
Ygs = Ygs[rownames(Ygs) != "Gene.Il1b", ]  # Next to Gene.Il1a;  KEGG_APOPTOSIS%%M8492
Ygs = Ygs[rownames(Ygs) != "Gene.Birc2", ] # Next to Gene.Birc3; KEGG_APOPTOSIS%%M8492
```

## Co-regulation; PCA

Plot first few principal components.

```{r}
sYgs = svd(Ygs)

set.seed(123)
sYgsdnull = sapply(
  1:100,
  function (i) {
    Ygspermute = Y[sample(1:nrow(Y), nrow(Ygs)), ]
    return(svd(Ygspermute)$d)
  })

# Do the first few element attains P < 0.05 ?
# From a descriptive statistics viewpoint, we don't care.
head(rowMeans(sYgsdnull > sYgs$d))
plot(sYgs$d)

dataplot = as.data.frame(sYgs$u)
dataplot$genename = rownames(Ygs)
dataplot$statistic = resultcompared$statistic[match(dataplot$genename, resultcompared$genename)]

# Are there new genes not in gs?  Not really.
quantile(sYgs$u - Ygs %*% sYgs$v %*% diag(1 / sYgs$d), c(0, 1))
dataplot = as.data.frame(Y %*% sYgs$v %*% diag(1 / sYgs$d))
dataplot$genename = rownames(dataplot)
dataplot$statistic = resultcompared$statistic[match(dataplot$genename, resultcompared$genename)]

ggplot(data = dataplot,
       aes(x = V1, y = V2)) +
  geom_text(
    aes(
      label = sub("^Gene.", "", genename),
      col = statistic),
    size = 3) +
  scale_color_gradient2(low = "blue", mid = "black", high = "red", midpoint = 0) + # TODO IMPROVE
  labs(x = paste0("PC 1 (", sprintf("%.3f", sYgs$d[1]^2 / sum(sYgs$d^2)), " of total variance)" ),
       y = paste0("PC 2 (", sprintf("%.3f", sYgs$d[2]^2 / sum(sYgs$d^2)), " of total variance)" ))
```

## Co-regulation; GENIE3

Gene-gene regulation

TODO: Instead of using Y (within environment dispersion; centralized per diet),
include diet conditions in regulators of GENIE3.
This can handle non-linearity and should be more robust.

```{r}
library(GENIE3)

set.seed(123)
weightMatrix = GENIE3(
  Ygs,
  nCores = 22,
  verbose = TRUE)

# saveRDS(weightMatrix, file = paste0("GENIE3_GeneGene.",  tgtct, ".", gsname, ".rds"))
weightMatrix = readRDS(paste0("GENIE3_GeneGene.",  tgtct, ".", gsname, ".rds"))
rownames(weightMatrix) = sub("^Gene.", "", rownames(weightMatrix))
colnames(weightMatrix) = sub("^Gene.", "", colnames(weightMatrix))

heatmap(weightMatrix, Rowv = NA, Colv = NA, scale = "none", cexRow = 0.5, cexCol = 0.5)
```

Clean noise.

```{r}
plot(sort(as.numeric(weightMatrix)))
# x = median(colQuantiles(weightMatrix, probs = 0.95))
x = median(
  apply(
    weightMatrix,
    2,
    function (x) sort(x, decreasing = TRUE)[3])) # keep top 3 regulators
abline(a = x, b = 0)
weightMatrix = weightMatrix - x
weightMatrix[weightMatrix < 0] = 0

heatmap(weightMatrix, Rowv = NA, Colv = NA, scale = "none", cexRow = 0.5, cexCol = 0.5)
heatmap(1*(weightMatrix>0), Rowv = NA, Colv = NA, scale = "none", cexRow = 0.5, cexCol = 0.5)
plot(sort(rowMeans(weightMatrix)))
plot(sort(rowMeans(weightMatrix > 0)))
tail(sort(rowMeans(weightMatrix)))
tail(sort(rowMeans(weightMatrix > 0)))
tail(sort(colMeans(weightMatrix)))
tail(sort(colMeans(weightMatrix > 0)))
plot(rowMeans(weightMatrix), rowMeans(weightMatrix > 0)) # diagonal
plot(colMeans(weightMatrix), colMeans(weightMatrix > 0)) # no
```

Represent regulatory relation in directed graph.

```{r}
library(igraph)
links = data.frame(
  source = rep(rownames(weightMatrix), times = ncol(weightMatrix)),
  target = rep(colnames(weightMatrix), each = nrow(weightMatrix)),
  weight = as.numeric(weightMatrix))
links = links[links$weight > 0, ]
nodes = data.frame(
    name = unique(c(links$source, links$target)))
nodes$statistic = resultcompared$statistic[
  match(paste0("Gene.", nodes$name), resultcompared$genename)]
# nodes$color = gray(
#   (nodes$statistic - min(nodes$statistic)) /
#     (max(nodes$statistic) - min(nodes$statistic)))
nodes$color = rgb(
  1 + (nodes$statistic / max(abs(nodes$statistic))) * (nodes$statistic < 0),
  1 - (nodes$statistic / max(abs(nodes$statistic))) * (nodes$statistic > 0),
  1 - (nodes$statistic / max(abs(nodes$statistic))) * (nodes$statistic > 0))
# nodes$outdegree = rowSums(weightMatrix)[nodes$name]
# nodes$outdegree = nodes$outdegree / max(nodes$outdegree)
# outdegree = rowSums(weightMatrix)
outdegree = rowSums(weightMatrix > 0)
outdegree = outdegree / max(outdegree)

network = graph_from_data_frame(d = links, vertices = nodes, directed = TRUE)
plot(network)
set.seed(123)
plot(network,
     # edge.width = rank(E(network)$weight)/30,
     # edge.width = E(network)$weight * 100,
     # vertex.size = eigen_centrality(network)$vector * 10 + 5,
     vertex.size = outdegree[V(network)$name] * 10 + 5,
     vertex.frame.color = NA,
     edge.curved = 0.3,
     edge.arrow.size = 0.6,
     layout=layout_with_dh)
  # layout=layout_with_gem)
  # layout=layout_with_graphopt)
  # layout=layout_with_lgl)
```

