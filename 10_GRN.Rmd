---
title: "GRN"
output: html_notebook
---

Apart from the section "Preprocess", other sections can be executed independently.

# Preprocess

Target cell type

```{r}
tgtct =
  "hepato"
  # "stellate"
  # "endothelial"
  # "myelo"
  # "T_NK"
```

Beforehand,
load `resultcompared` from `7_GeneScoreMatrix.Rmd` and rename to `resultcomparedGene`.
Load `redundantGene` and `matnrGene` from `7_GeneScoreMatrix.Rmd`.
Load `resultcompared` from `8_MotifMatrix.Rmd` and rename to `resultcomparedMotif`.
Load `redundantMotif` and `matnrMotif` from `8_MotifMatrix.Rmd`.

```{r}
identical(colnames(matnrGene), colnames(matnrMotif))
```

Inspect.

```{r}
ggplot(data = data.frame(
  x = assay(matnrGene)["Gene.Abcg1", ],
  y = assay(matnrMotif)["Motif.Stat5b", ],
  s = as.character(matnrGene$Sample)),
  aes(x, y)) +
  geom_point(size = 0.5) +
  facet_grid(cols = vars(s))
```

Filter differentially expressed genes/motifs.
For robustness, we impose abs(estimate) > log2(1.1), which is arbitrary (especially for Motif).

```{r}
x = resultcomparedGene %>%
  dplyr::filter(abs(estimate) > log2(1.1) & FDR < 0.01 & celltype == tgtct) %>%
  dplyr::distinct(genename) %>%
  dplyr::pull(genename)
matnrDEGene = matnrGene[which(rownames(matnrGene) %in% paste0("Gene.", x)), ]

x = resultcomparedMotif %>%
  dplyr::filter(abs(estimate) > log2(1.1) & FDR < 0.01 & celltype == tgtct) %>%
  dplyr::distinct(genename) %>%
  dplyr::pull(genename)
matnrDEMotif = matnrMotif[which(rownames(matnrMotif) %in% paste0("Motif.", x)), ]
```

# One motif-to-one gene analysis

## Correlation between motifs and genes

```{r}
corMG = cor(
  t(assay(matnrMotif)),
  t(assay(matnrGene)),
  method = "spearman")

cornulldistribution =
  sapply(
    1:100,
    function (i) {
      print(i)
      set.seed(i)
      corMGsim = cor(
        t(assay(matnrMotif))[sample(ncol(matnrMotif)), ],
        t(assay(matnrGene)),
        method = "spearman")
      sapply(0:1000, function (x) { sum(abs(corMGsim) > x/1000) })
    })

thresholdFDR001 =
  max(which(
    rowMeans(cornulldistribution) /
      sapply(0:1000, function (x) { sum(abs(corMG) > x/1000) }) >= 0.01)) / 1000
# FDR<0.01
# >0.035 ; hepato

thresholdglobalP005 =
  mean(sort(
    apply(
      cornulldistribution,
      2,
      function (x) { (max(which(x > 0)) - 1)/1000 }),
    decreasing = TRUE)[5:6])
# globalP=0.05
# 0.062 ; hepato

# Mask unless FDR<0.01
corMGsig = corMG
corMGsig[abs(corMGsig) <= thresholdFDR001] = 0
```

Filter differentially expressed genes/motifs.

```{r}
all(rownames(matnrDEMotif) %in% rownames(corMGsig))
all(rownames(matnrDEGene)  %in% colnames(corMGsig))
corMGsigsig = corMGsig
corMGsigsig = corMGsigsig[rownames(matnrDEMotif), ]
corMGsigsig = corMGsigsig[, rownames(matnrDEGene)]
plot(quantile(abs(corMGsigsig), seq(0, 1, 0.01)))
```

## SVD of corMGsigsig

For hepato, 7 components look significant.
They tend to overlap with factors (modules) found below
in section 'Multiple motifs-to-one gene analysis'

```{r}
x = svd(corMGsigsig)
plot(x$d)
dataplot =
  as.data.frame(x$u); rownames(dataplot) = rownames(corMGsigsig)
  # as.data.frame(x$v); rownames(dataplot) = colnames(corMGsigsig)
ggplot(data = dataplot,
       aes(x = V1,
           y = V2)) +
  geom_point(size = 0.5)

i = 1
w = x$u[, i]
names(w) = rownames(corMGsigsig)
w[head(order(abs(w), decreasing = TRUE), 10)]
w = x$v[, i]
names(w) = colnames(corMGsigsig)
w[head(order(abs(w), decreasing = TRUE), 10)]
```

## Graph of corMGsigsig

```{r}
library(igraph)

x = as.character()
for (j in 1:ncol(corMGsigsig)) {
  connected = corMGsigsig[, j]
  connected = connected[abs(connected) > 0]
  if (length(connected) > 0) {
    connected = connected[head(order(abs(connected), decreasing = TRUE), 5)]
    x = c(x,
          as.character(
            rbind(
              names(connected),
              colnames(corMGsigsig)[j])
          ))
  }
}
corMGsigsiggraph = graph(edges = x, directed = TRUE)
corMGsigsiggraphcomp = igraph::components(corMGsigsiggraph, mode = "weak")
corMGsigsiggraphcomp$csize
head(sort(degree(corMGsigsiggraph), decreasing = TRUE))
```

## Detect mediator motifs by conditional analysis; diminished t-statistic

We are interested if the effect of condition (ie diet) on Gene j
is mediated by Motif i.
We want to detect the information flow (causality) "condition -> Motif i -> Gene j".
It doesn't matter whether there is bypass "condition -> Gene j".
We test if the association of Gene j with condition decreases
when conditioned by Motif i.

```{r}
x = matnrDEMotif
y = matnrDEGene
g = x$Sample
g[g %in% c("m154211", "m167108")] = "sp"
x$spdietcombined = g
```

Compute the regression
condition ~ (Motif i) + (Gene j),
and keep the t-statistic for (Gene j).
For a fixed j, which i yields diminished t-statistic?

```{r}
cl = makeCluster(20)
clusterExport(cl, "assay")
clusterExport(cl, "x")
clusterExport(cl, "y")
# TODO CCA with all conditions combined as y
statadjusted =
  do.call(
    rbind,
    lapply(
      c("m154207", "m167203", "m168101"),
      function (s) {
        print(s)
        cond = as.character(x$spdietcombined)
        cond[! cond %in% c(s, "sp")] = NA
        do.call(
          rbind,
          lapply(
            row.names(x),
            function (i) {
              print(i)
              do.call(
                rbind,
                # lapply(
                parLapply(cl = cl,
                  row.names(y),
                  function (j) {
                    a0 = lm(y ~ x,
                            data = list(
                              y = (cond != "sp"),
                              x = cbind(
                                t(assay(y)[j, , drop = FALSE]),
                                t(assay(x)[i, , drop = FALSE]))))
                    data.frame(
                      Motif = i,
                      Gene = j,
                      sample = s,
                      statadjusted = summary(a0)$coefficients[2, "t value"])
                  }))
            }))
      }))
# saveRDS(statadjusted, file = paste0("statadjusted.", tgtct, ".rds"))
statadjusted = readRDS(paste0("statadjusted.", tgtct, ".rds"))
```

Overlay statadjusted with corMGsigsig.
We discard motif-gene pairs where corMGsigsig = 0.

```{r}
s = "m154207"
s = "m167203"
s = "m168101"

library(dplyr)
clusterExport(cl, c("s", "corMGsigsig", "statadjusted",
                    "filter",
                    "select",
                    "slice_min",
                    "arrange",
                    "%>%"))
statadjustededges =
  # sapply(
  parSapply(cl = cl,
    colnames(corMGsigsig),
    function (tgtgene) {
      data =
        statadjusted %>%
        dplyr::filter(Gene == tgtgene) %>%
        dplyr::filter(sample == s) %>%
        dplyr::select(Motif, statadjusted)
      data$corMGsigsig = corMGsigsig[data$Motif, tgtgene]
      data$statadjustedpos =
        data$statadjusted *
        sign(median(data$statadjusted))
      statadjustedposlb =
        2.5 * quantile(data$statadjustedpos, 0.25) +
        (-1.5) * quantile(data$statadjustedpos, 0.75)
      dataupstreamMotif =
        data %>%
        dplyr::filter(statadjustedpos < statadjustedposlb) %>%
        dplyr::filter(statadjustedpos >= 0) %>%
        dplyr::filter(corMGsigsig > sqrt(0.5) * max(data$corMGsigsig) |
                        corMGsigsig < sqrt(0.5) * min(data$corMGsigsig)) %>%
        dplyr::slice_min(statadjustedpos, n = 10) %>%
        dplyr::arrange(statadjustedpos)
      x = rep(0, nrow(corMGsigsig))
      names(x) = row.names(corMGsigsig)
      if (nrow(dataupstreamMotif) > 0) {
        x[dataupstreamMotif$Motif] = 1
      }
      return(x)
    })

plot(log10(sort(rowSums(statadjustededges))))
plot(
  log10(rank(- rowSums(statadjustededges))),
  log10(rowSums(statadjustededges)))
head(sort(rowSums(statadjustededges), decreasing = TRUE), 20)
```

The motifs with higher degrees (ie hubs)
show larger differential expression under diet intervention.
However, the corresponding genes (mRNA) of the motif are not differentially expressed.

```{r}
plotdata = data.frame(
  statadjustededges = rowSums(statadjustededges))
foo = resultcomparedMotif[
  resultcomparedMotif$celltype == tgtct &
    resultcomparedMotif$sample == s, ]
plotdata$resultcomparedMotif =
  foo$statistic[match(sub("^Motif.", "", rownames(plotdata)), foo$genename)]
foo = resultcomparedGene[
  resultcomparedGene$celltype == tgtct &
    resultcomparedGene$sample == s, ]
plotdata$resultcomparedGene =
  foo$statistic[match(sub("^Motif.", "", rownames(plotdata)), foo$genename)]
ggplot(data = plotdata) +
  geom_point(
    aes(x = log1p(statadjustededges),
        y = resultcomparedMotif,
        col = resultcomparedGene)) +
  scale_color_gradient2(low = "blue", mid = "white", high = "red")
```

Clustering of motifs

```{r}
foo = statadjustededges[rowSums(statadjustededges) >= 200, ]
# heatmap(foo)
plot(
  hclust(dist(foo, method = "binary"), method = "average"),
  cex = 0.5)
```

## Detect mediator motifs by conditional analysis; mutual information

We want to detect the information flow (causality) "condition -> Motif i -> Gene j".
It doesn't matter whether there is bypass "condition -> Gene j".
In the language of entropy and mutual information, we detect by
mutual_info(Gene j; Motif i; condition) / entropy(Gene j) > 0.
Remark that
mutual_info(Gene j; Motif i; condition)
= mutual_info(Gene j; Motif i)
+ mutual_info(Gene j; condition)
- mutual_info(Gene j; Motif i, condition)
Instead of entropy and mutual information,
we actually use R2 (explained variance) of linear regression.

```{r}
x = matnrDEMotif
y = matnrDEGene
d = data.frame(
  m154207 = (matnrDEGene$Sample == "m154207"),
  m167203 = (matnrDEGene$Sample == "m167203"),
  m168101 = (matnrDEGene$Sample == "m168101"))
d = t(as.matrix(d) * 1)
```

```{r}
residualnull = rowSums( (assay(y) - rowMeans(assay(y)))^2 )

a1 = lm(t(assay(y)) ~ t(d))
R2diet = 1 - colSums(a1$residuals^2) / residualnull

cl = makeCluster(20)
clusterExport(cl, "assay")
clusterExport(cl, "x")
clusterExport(cl, "y")
clusterExport(cl, "d")
clusterExport(cl, "residualnull")
R2Motif =
  do.call(
    rbind,
    # lapply(
    parLapply(cl = cl,
              row.names(x),
              function (i) {
                a1 = lm(t(assay(y)) ~ assay(x)[i, ])
                1 - colSums(a1$residuals^2) / residualnull
              }))
R2Motifdiet =
  do.call(
    rbind,
    # lapply(
    parLapply(cl = cl,
              row.names(x),
              function (i) {
                print(i)
                a1 = lm(t(assay(y)) ~ cbind(assay(x)[i, ], t(d)))
                1 - colSums(a1$residuals^2) / residualnull
              }))
R2Motifdietmutual =
  R2Motif + matrix(R2diet, nrow = nrow(x), ncol = nrow(y), byrow = TRUE) - R2Motifdiet
R2Motifdietmutual[R2Motifdietmutual < 0] = 0
rownames(R2Motifdietmutual) = rownames(x)
# saveRDS(R2Motifdietmutual, paste0("R2Motifdietmutual.", tgtct, ".rds"))
R2Motifdietmutual = readRDS(paste0("R2Motifdietmutual.", tgtct, ".rds"))
```

```{r}
head(sort(rowMeans(R2Motifdietmutual), decreasing = TRUE))
head(sort(rowMeans(R2Motifdietmutual > 0), decreasing = TRUE))
```

# Multiple motifs-to-one gene analysis

## Compute regulatory motifs by using GENIE3

Include experimental condition as predictor.

```{r}
x = data.frame(
  m154207 = (matnrDEGene$Sample == "m154207"),
  m167203 = (matnrDEGene$Sample == "m167203"),
  m168101 = (matnrDEGene$Sample == "m168101"))
x = t(as.matrix(x) * 1)
```

For each gene, compute "regulatory" motifs.

```{r}
library(GENIE3)

set.seed(123)
weightMatrix = GENIE3(
  rbind(
    assay(matnrDEGene),
    assay(matnrDEMotif),
    x),
  targets = rownames(matnrDEGene),
  regulators = c(rownames(matnrDEMotif), rownames(x)),
  nCores = 22,
  verbose = TRUE)

# saveRDS(weightMatrix, file = paste0("GENIE3.",  tgtct, ".rds"))
weightMatrix = readRDS(paste0("GENIE3.",  tgtct, ".rds"))
```

Clean noise.

```{r}
plot(quantile(weightMatrix, seq(0, 1, 0.01)))
plot(quantile(weightMatrix, seq(1 - 1e-3, 1, 1e-5)))
plot(quantile(weightMatrix, seq(1 - 1e-4, 1, 1e-6)))

x = min(colQuantiles(weightMatrix, probs = 0.95))
weightMatrix = weightMatrix - x
weightMatrix[weightMatrix < 0] = 0

plot(sort(rowMeans(weightMatrix)))
# TODO change from 1e-4 to quantile(rowMeans(weightMatrix), 0.85)
weightMatrix = weightMatrix[rowMeans(weightMatrix) > 1e-4, ] # arbitrary
# stellate:    drops m167203 m168101 
# endothelial: drops m167203
# myelo:       drops m167203 m168101 
# T_NK:        drops all experimental conditions

# zero columns cause error in nmf
weightMatrix = weightMatrix[, colMaxs(weightMatrix) > 0]

plot(hclust(dist(weightMatrix)))
```

## Nonnegative matrix factorization of regulator-regulatee matrix

To choose the optimal value of r, first try 1; if not clear try 2.
1. (Hutchins2008) suggested to choose the first value where the RSS curve presents an inflection point, and (Frigyesi2008) considered the value of r after which the decrease in the RSS becomes lower than the decrease of the RSS obtained from random data.
2. (Brunet2004) proposed to take the value of r after which the cophenetic coefficient starts to drop steeply.

```{r}
library(NMF)

gc()
estim.r = nmf(weightMatrix,
              rank = 2:6,
              nrun = 30, # 10 30
              seed = 123456,
              .opt = 'vP4') # P5 error
# plot(estim.r)

set.seed(123456)
V.random = randomize(weightMatrix)
gc()
estim.r.random = nmf(V.random,
                     rank = 2:6,
                     nrun = 30, # 10 30
                     seed = 123456,
                     .opt = 'vP4')
# plot(estim.r, estim.r.random)
rm(V.random)

r = 4 # hepato stellate myelo
r = 3 # endothelial T_NK

# res.nndsvd = nmf(weightMatrix,
#                  rank = r,
#                  seed = 'nndsvd')

gc()
res = nmf(weightMatrix,
          rank = r,
          nrun = 100, # 10 100
          seed = 123456,
          .opt = 'vP4')
summary(res, target = weightMatrix)
# saveRDS(res, file = paste0("GENIE3.NMF.rank", r, ".", tgtct, ".rds"))
res = readRDS(paste0("GENIE3.NMF.rank", r, ".", tgtct, ".rds"))

basismap(res)
# coefmap(res)
summary(basis(res))
summary(t(coefficients(res)))
basis(res)["Motif.Hnf4g", ]
```

In `summary(t(coefficients(res)))`, one factor has large median and 3rd quantile.
Does it correspond to "all of the remaining genes"?
The basis for the factor includes Motif.Hnf4g.
We set this factor as the last one in moduleindex.
Motif.Hnf4g is up in m154207 (HFD4w) and down in m168101 (washout).  Why??

This setting is for visualization.
We set the factor(s) with significant GSEA in the beginning (see below).

```{r}
# hepato
moduleindex = c(4, 2, 1, 3)
# stellate
moduleindex = c(1, 2, 4, 3)
# endothelial
moduleindex = c(3, 1, 2)
# myelo
moduleindex = c(3, 1, 2, 4)
# T_NK
moduleindex = c(2, 1, 3)
```

Draw heatmap for regulation of genes by motifs.

```{r}
topMotiflist = lapply(
  moduleindex,
  function (i) {
    x = sort(basis(res)[, i], decreasing = TRUE)
    x = x[! names(x) %in% grep("^m", names(x), value = TRUE)]
    x = x[x > max(x) / 2]
    return(head(names(x), 5))
  })
topMotif = union(do.call(c, topMotiflist), c())

topGenelist = lapply(
  moduleindex,
  function (i) {
    x = sort(coef(res)[i, ], decreasing = TRUE)
    x = x[x > max(x) / 2]
    return(head(names(x), 5))
  })
topGene = union(do.call(c, topGenelist), c())

weightMatrix = readRDS(paste0("GENIE3.",  tgtct, ".rds"))
x = t(weightMatrix[topMotif, topGene])
rownames(x) = sub("^Gene.", "", rownames(x))
colnames(x) = toupper(sub("^Motif.", "", colnames(x)))

aC = as.data.frame(basis(res)[topMotif, moduleindex])
names(aC) = paste0("Motif.M", 1:ncol(aC))
aR = as.data.frame(t(coef(res)[moduleindex, topGene]))
names(aR) = paste0("Gene.M", 1:ncol(aR))
NMF::aheatmap(
  x,
  color = c("white", "black"),
  Rowv = NA,
  Colv = NA,
  annCol = aC,
  annRow = aR,
  annColors = rep(list(c("white", "black")), dim(res)[3] * 2),
  main = tgtct,
  treeheight = 0,
  filename = "NMF.heatmap.pdf", width = 5, height = 5)
```

## Hyperparameters for the discovery of factors (modules) of TF regulation

Post-hoc analysis of the hyperparameters for machine learning by GENIE3 and NMF.
This section can be skipped.
Precomputed results are available as GENIE3_NMF_hyperparameters.zip from figshare.

TF modules were computed in two steps, first the regulator-regulatee matrix was computed using GENIE3, then the modules were extracted by nonnegative matrix factorization using NMF. We assessed the accuracy of TF module discovery under a range of hyperparameters by randomly dividing the hepatocytes into two sets of halves (4136 nuclei in each set), computing in each set the regulator-regulatee matrix, approximating the matrix using NMF (with nonnegative double singular value decomposition seed), and then calculating the correlation coefficient between the two NMF-approximated regulator-regulatee matrices. A larger correlation coefficient indicates a higher accuracy. To estimate the noise level, we performed the same process in each set but with nuclei labeling of the Gene Score Matrix randomly permuted while keeping the Motif Matrix intact. Under each setting of the hyperparameter, we performed five permutation trials.

GENIE3.

```{r}
for (samplingseed in 1:5) {
  print(samplingseed)
  
  set.seed(samplingseed)
  A = sort(sample(1:ncol(matnrDEGene), floor(ncol(matnrDEGene) / 2)))
  B = setdiff(1:ncol(matnrDEGene), A)
  perm = sample(1:ncol(matnrDEGene))
  
  library(GENIE3)
  
  set.seed(123)
  weightMatrix = GENIE3(
    rbind(
      # assay(matnrDEGene)[, A],
      # assay(matnrDEMotif)[, A],
      # x[, A]),
      # assay(matnrDEGene)[, B],
      # assay(matnrDEMotif)[, B],
      # x[, B]),
      # assay(matnrDEGene)[, perm][, A],
      # assay(matnrDEMotif)[, A],
      # x[, A]),
      assay(matnrDEGene)[, perm][, B],
      assay(matnrDEMotif)[, B],
      x[, B]),
    targets = rownames(matnrDEGene),
    regulators = c(rownames(matnrDEMotif), rownames(x)),
    nCores = 22,
    K = 1, # unset, 1 or 30
    verbose = TRUE)
  
  saveRDS(weightMatrix,
          file = paste0("GENIE3.",  tgtct,
                        ".samplingseed_", samplingseed,
                        # ".A.rds"))
                        # ".B.rds"))
                        # ".permA.rds"))
                        # ".permB.rds"))
                        # ".A.K_1.rds"))
                        # ".B.K_1.rds"))
                        # ".permA.K_1.rds"))
                        ".permB.K_1.rds"))
                        # ".A.K_30.rds"))
                        # ".B.K_30.rds"))
                        # ".permA.K_30.rds"))
                        # ".permB.K_30.rds"))
}
```

NMF.

```{r}
for (samplingseed in 1:5) {
  print(samplingseed)
  weightMatrix =
    readRDS(paste0("GENIE3.",  tgtct,
                   ".samplingseed_", samplingseed,
                   # ".A.rds"))
                   # ".B.rds"))
                   # ".permA.rds"))
                   # ".permB.rds"))
                   # ".A.K_1.rds"))
                   # ".B.K_1.rds"))
                   # ".permA.K_1.rds"))
                   # ".permB.K_1.rds"))
                   ".A.K_30.rds"))
                   # ".B.K_30.rds"))
                   # ".permA.K_30.rds"))
                   # ".permB.K_30.rds"))
  weightMatrixraw = weightMatrix
  
  x = min(colQuantiles(weightMatrix, probs = 0.95))
  weightMatrix = weightMatrix - x
  weightMatrix[weightMatrix < 0] = 0
  
  weightMatrix = weightMatrix[rowMeans(weightMatrix) >
                                quantile(rowMeans(weightMatrix), 0.85), ] # arbitrary
  
  # zero columns cause error in nmf
  weightMatrix = weightMatrix[, colMaxs(weightMatrix) > 0]
  
  library(NMF)
  for (r in 4) { # c(2, 4, 6, 8)
    print(r)
    res.nndsvd = nmf(weightMatrix,
                     rank = r,
                     seed = 'nndsvd')
    
    x = basis(res.nndsvd) %*% coef(res.nndsvd)
    weightMatrixapprox = weightMatrixraw * 0
    weightMatrixapprox =
      x[match(rownames(weightMatrixapprox), rownames(x)),
        match(colnames(weightMatrixapprox), colnames(x))]
    weightMatrixapprox[is.na(weightMatrixapprox)] = 0
    rownames(weightMatrixapprox) = rownames(weightMatrixraw)
    saveRDS(weightMatrixapprox,
            file = paste0("GENIE3.NMFnndsvd.rank",  r, ".",
                          tgtct,
                          ".samplingseed_", samplingseed,
                          # ".A.rds"))
                          # ".B.rds"))
                          # ".permA.rds"))
                          # ".permB.rds"))
                          # ".A.K_1.rds"))
                          # ".B.K_1.rds"))
                          # ".permA.K_1.rds"))
                          # ".permB.K_1.rds"))
                          ".A.K_30.rds"))
                          # ".B.K_30.rds"))
                          # ".permA.K_30.rds"))
                          # ".permB.K_30.rds"))
  }
}
```

Summarize and plot.

```{r}
datasmall =
  do.call(
    rbind,
    lapply(
      c(2, 4, 6, 8),
      # 4,
      function(r) {
        do.call(
          rbind,
          lapply(
            1:5,
            function (samplingseed) {
              A = readRDS(paste0("GENIE3.NMFnndsvd.rank",  r, ".",
                                 tgtct,
                                 ".samplingseed_", samplingseed,
                                 ".A.rds"))
                                 # ".permA.rds"))
                                 # ".A.K_1.rds"))
                                 # ".permA.K_1.rds"))
                                 # ".A.K_30.rds"))
                                 # ".permA.K_30.rds"))
              B = readRDS(paste0("GENIE3.NMFnndsvd.rank",  r, ".",
                                 tgtct,
                                 ".samplingseed_", samplingseed,
                                 ".B.rds"))
                                 # ".permB.rds"))
                                 # ".B.K_1.rds"))
                                 # ".permB.K_1.rds"))
                                 # ".B.K_30.rds"))
                                 # ".permB.K_30.rds"))
              data.frame(
                Rank = r,
                samplingseed = samplingseed,
                Correlation = cor(as.numeric(A), as.numeric(B)), # use this
                error = sum((A/sum(A) - B/sum(B))^2))
            }))
      }))
datasmall$K = 30 # 1 23(unset) 30
datasmall$K = factor(datasmall$K)
datasmall$Rank = factor(datasmall$Rank)
datasmall$type = "Permutation" # Raw Permutation

# Manually combine datasmall's as data

library(dplyr)
library(ggplot2)
data$type = factor(data$type, levels = c("Raw", "Permutation"))
dataplot = data %>%
  group_by(Rank, type) %>%
  # group_by(K, type) %>%
  summarize(Mean = mean(Correlation), SD = sd(Correlation),
            .groups = "drop")
ggplot(data = data,
       aes(
         x = Rank,
         # x = K,
         y = Correlation)) +
  geom_point(size = 0.7) +
  geom_crossbar(
    data = dataplot,
    aes(
      x = Rank,
      # x = K,
      y = Mean,
      ymin = Mean - SD,
      ymax = Mean + SD)) +
  ylim(0, 1) +
  facet_grid(cols = vars(type))
```

## Gene set enrichment analysis for genes belonging to factors (modules)

Load `gslists` from `9_GSEA.Rmd`.

```{r}
x = as.data.frame(t(coef(res)))
row.names(x) = sub("^Gene.", "", row.names(x))
set.seed(123)
result =
  lapply(
    1:ncol(x),
    function (j) {
      print(j)
      lapply(
        gslists,
        function (gslist) {
          gslistresult =
            do.call(
              rbind,
              lapply(
                gslist,
                function (gs) {
                  ings = (row.names(x) %in% gs)
                  if (min(sum(ings), sum(! ings)) < 5) {
                    return(data.frame(statistic = NA, p.value = NA))
                  } else {
                    return(
                      as.data.frame(
                        t.test(
                          x[ings, j],
                          x[! ings, j],
                          alternative = "greater",
                          var.equal = TRUE)[c("statistic", "p.value")]))
                  }}))
          statisticnull =
            sapply(
              1:100,
              function (i) {
                sapply(
                  gslist,
                  function (gs) {
                    ings = (row.names(x) %in% gs)[sample(nrow(x))]
                    if (min(sum(ings), sum(! ings)) < 5) {
                      return(NA)
                    } else {
                      return(
                        t.test(
                          x[ings, j],
                          x[! ings, j],
                          alternative = "greater",
                          var.equal = TRUE)$statistic)
                    }})
              })
          statisticnull = colMaxs(statisticnull, na.rm = TRUE)
          gslistresult$fwe =
            sapply(
              gslistresult$statistic,
              function (s) { mean(s <= statisticnull) })
          return(gslistresult)
        })
    })
# saveRDS(result, file = paste0("GENIE3.NMF.rank", r, ".", tgtct, ".GSEA.rds"))
result = readRDS(paste0("GENIE3.NMF.rank", r, ".", tgtct, ".GSEA.rds"))
```

## Inspect enriched gene sets

When there are too many gene sets attaining family-wise error rate (fwe) < 0.05,
visualize and choose representatives by using Cytoscape:
1. Apps > EnrichmentMap. Import GMT file `foo.gmt`
2. Node Table. Import `foo.txt` and add column log10P
3. Style > Fill Color > Map. Column = log10Ppadog. Mapping Type = Continuous Mapping
4. [Optional] Apps > clusterMaker > MCODE Cluster. Create new clustered network
5. Layout > yFiles Radial Layout

Generate files to be loaded to Cytoscape.

```{r}
j = 1
data = result[[j]]
data = data[c(1:7, 9)]
data = do.call(rbind, data)
data$Name = rownames(data)
datafwe005 = data[!is.na(data$fwe) & data$fwe < 0.05, ]
datafwe005$log10P = log10(datafwe005$p.value)
datafwe005 = datafwe005[order(datafwe005$p.value), ]
datafwe005
datafwe005[order(datafwe005$Name), ]
datafwe005$Name2 = sub("[^.]*\\.", "", datafwe005$Name, perl = TRUE)
write.table(
  datafwe005[, c("Name2", "log10P")],
  file = "foo.txt",
  row.names = FALSE,
  col.names = TRUE,
  sep = "\t",
  quote = FALSE)

output = do.call(c, gslists)
output = output[datafwe005$Name]
output = lapply(output, function (x) { paste0(x, collapse = "\t") })
x = names(output)
x = sub("[^.]*\\.", "", x, perl = TRUE)
output = paste(
  x,
  sub("%.*", "", x),
  unlist(output),
  sep = "\t")
cat(output, file = "foo.gmt", sep = "\n")
```

Gene sets of interest are handpicked and sorted by biological process.

```{r}
# * indicates "not significant in diet comparison"
dbnamegsname = rbind(
  data.frame(dbname = 'GOBP', gsname = 'GOBP_STEROID_METABOLIC_PROCESS%%M16758'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_REGULATION_OF_CHOLESTEROL_BIOSYNTHESIS_BY_SREBP_SREBF%%M27001'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_LIPID_STORAGE%%M15541'),
  data.frame(dbname = 'KEGG', gsname = 'KEGG_PPAR_SIGNALING_PATHWAY%%M13088'),
  data.frame(dbname = 'H', gsname = 'HALLMARK_XENOBIOTIC_METABOLISM%%M5934'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608'),
  
  data.frame(dbname = 'H', gsname = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB%%M5890'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_CYTOKINE_PRODUCTION%%M13156'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_RESPONSE_TO_CYTOKINE%%M15783'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_INTERLEUKIN_1_SIGNALING%%M27895'),
  data.frame(dbname = 'H', gsname = 'HALLMARK_IL2_STAT5_SIGNALING%%M5947'), # *
  data.frame(dbname = 'H', gsname = 'HALLMARK_IL6_JAK_STAT3_SIGNALING%%M5897'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_INTERLEUKIN_10_SIGNALING%%M27605'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_INFLAMMASOMES%%M1072'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_ADAPTIVE_IMMUNE_RESPONSE%%M13847'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_CREATION_OF_C4_AND_C2_ACTIVATORS%%M1078'), # *
  data.frame(dbname = 'GOBP', gsname = 'GOBP_MYELOID_LEUKOCYTE_ACTIVATION%%M12762'),
  data.frame(dbname = 'KEGG', gsname = 'KEGG_HEMATOPOIETIC_CELL_LINEAGE%%M6856'), # *
  data.frame(dbname = 'WIKIPATHWAYS', gsname = 'WP_ONCOSTATIN_M_SIGNALING_PATHWAY%%M39562'),
  
  data.frame(dbname = 'KEGG', gsname = 'KEGG_APOPTOSIS%%M8492'),
  data.frame(dbname = 'H', gsname = 'HALLMARK_APOPTOSIS%%M5902'), # *
  
  data.frame(dbname = 'GOBP', gsname = 'GOBP_ACTIN_FILAMENT_BASED_PROCESS%%M9082'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_CELL_MIGRATION%%M40389'),
  # stellate
  data.frame(dbname ="REACTOME", gsname = "REACTOME_EXTRACELLULAR_MATRIX_ORGANIZATION%%M610"), # *
  data.frame(dbname = 'GOBP', gsname = 'GOBP_SEMAPHORIN_PLEXIN_SIGNALING_PATHWAY%%M15378'), # *
  data.frame(dbname = 'H', gsname = 'HALLMARK_TGF_BETA_SIGNALING%%M5896'), # *
  # endothelial
  data.frame(dbname = 'WIKIPATHWAYS', gsname = 'WP_VEGFAVEGFR2_SIGNALING_PATHWAY%%M39729'), # *
  
  data.frame(dbname = 'H', gsname = 'HALLMARK_MITOTIC_SPINDLE%%M5893'), # *
  data.frame(dbname = 'H', gsname = 'HALLMARK_KRAS_SIGNALING_UP%%M5953'), # *
  data.frame(dbname = 'H', gsname = 'HALLMARK_PI3K_AKT_MTOR_SIGNALING%%M5923'), # *

  data.frame(dbname = 'WIKIPATHWAYS', gsname = 'WP_FARNESOID_X_RECEPTOR_PATHWAY%%M39411'), # *
  data.frame(dbname = 'GOBP', gsname = 'GOBP_GLUTAMINE_FAMILY_AMINO_ACID_BIOSYNTHETIC_PROCESS%%M10295') # *
)
```

Visualize GSEA results.

```{r}
dataplot = lapply(result[moduleindex], function (x) do.call(rbind, x))
dataplot = lapply(dataplot, function (x) x[paste0(dbnamegsname$dbname, ".", dbnamegsname$gsname), ])

x = do.call(cbind, lapply(dataplot, function (x) x[, "p.value", drop = FALSE]))
names(x) =  paste0("Module ", 1:ncol(x))
x$gsname = factor(rownames(x), levels = rownames(x))
dataplot.P = x
x = do.call(cbind, lapply(dataplot, function (x) x[, "fwe", drop = FALSE]))
names(x) =  paste0("Module ", 1:ncol(x))
significant = (rowSums(is.na(x)) == 0) & (rowMins(as.matrix(x), na.rm = TRUE) < 0.05)
x$gsname = factor(rownames(x), levels = rownames(x))
dataplot.fwe = x
dataplot.P = dataplot.P[significant, , drop = FALSE]
dataplot.fwe = dataplot.fwe[significant, , drop = FALSE]

dataplot.P = tidyr::pivot_longer(dataplot.P,
                                 cols = matches("^Module \\d+", perl = TRUE),
                                 names_to = "factor",
                                 values_to = "P")
dataplot.fwe = tidyr::pivot_longer(dataplot.fwe,
                                   cols = matches("^Module \\d+", perl = TRUE),
                                   names_to = "factor",
                                   values_to = "fwe")
dataplot =
  dplyr::left_join(dataplot.P, dataplot.fwe, by = c("gsname", "factor"))

p1 =
  ggplot(dataplot,
         aes(x = gsname,
             y = - log10(P))) +
  geom_bar(stat = "identity",
           aes(fill = (fwe < 0.05))) +
  scale_fill_manual(values = c("gray50", "black")) +
  guides(fill = "none") +
  facet_grid(rows = vars(factor)) +
  theme(axis.text.x = element_text(angle = 90,
                                   hjust = 1,
                                   vjust = 0.5,
                                   size = rel(0.4))) +
  labs(title = tgtct,
       x = NULL)
show(p1)
# ggsave(p1, filename = "modulescore_GSEA.Gene.pdf", width = 3.15, height = 5.65)
```

## Visualize NMF VarianceImportance vs differential expression

```{r}
# Run this for Motif
x = as.data.frame(basis(res))
x = x[, moduleindex, drop = FALSE]
names(x) = paste0("Module ", 1:ncol(x))
x$genename = row.names(x)
x = tidyr::pivot_longer(x,
                        cols = matches("^Module \\d+", perl = TRUE),
                        names_to = "factor",
                        values_to = "score")
x$intop = FALSE
for (i in 1:length(topMotiflist)) {
  x$intop[(x$genename %in% topMotiflist[[i]]) &
            (x$factor == paste0("Module ", i))] = TRUE
}
x$genename = sub("^Motif.", "", x$genename)
dataplot = resultcomparedMotif %>%
  dplyr::filter(celltype == tgtct)

# Run this for Gene
x = as.data.frame(t(coef(res)))
x = x[, moduleindex, drop = FALSE]
names(x) = paste0("Module ", 1:ncol(x))
x$genename = row.names(x)
x = tidyr::pivot_longer(x,
                        cols = matches("^Module \\d+", perl = TRUE),
                        names_to = "factor",
                        values_to = "score")
x$intop = FALSE
for (i in 1:length(topGenelist)) {
  x$intop[(x$genename %in% topGenelist[[i]]) &
            (x$factor == paste0("Module ", i))] = TRUE
}
x$genename = sub("^Gene.", "", x$genename)
dataplot = resultcomparedGene %>%
  dplyr::filter(celltype == tgtct)

dataplot = dplyr::inner_join(dataplot, x, by = "genename")
p1 =
  ggplot(data = dataplot,
         aes(x = statistic,
             y = score)) +
  geom_point(aes(color = intop), size = 0.3) +
  scale_color_manual(values = c("black", "red"), guide = "none") +
  facet_grid(rows = vars(factor),
             cols = vars(sample),
             scales = "free_y") +
  labs(x = "Differential expression by diet [Z statistic]",
       y = "Module score") +
  theme(axis.text.x = element_text(size = rel(0.75)),
        axis.text.y = element_text(size = rel(0.75))) +
  theme(panel.spacing.y = unit(1, "lines"))
ggsave(p1, filename = "modulescore_DE.pdf", width = 3.5, height = 4)
```

Although all components could be associated with diet,
quantify to inspect which component is strongly associated with differential gene expression.

```{r}
library(dplyr)

x = as.data.frame(t(coef(res)))
x = x[, moduleindex, drop = FALSE]
names(x) = paste0("Module ", 1:ncol(x))
x$genename = sub("^Gene.", "", row.names(x))
x = tidyr::pivot_longer(x,
                        cols = matches("^Module \\d+", perl = TRUE),
                        names_to = "factor",
                        values_to = "score")
data = resultcomparedGene %>%
  dplyr::filter(celltype == tgtct)
data = dplyr::inner_join(data, x, by = "genename")

data %>%
  dplyr::group_by(factor, sample) %>%
  dplyr::summarize(
    statpos = summary(lm(statistic^2 ~ score + 0,
                         weights = score^2,
                         subset = statistic > 0))$coefficients[3],
    statneg = summary(lm(statistic^2 ~ score + 0,
                         weights = score^2,
                         subset = statistic < 0))$coefficients[3],
    .groups = "drop")
```

## SVD based on weighting by NMF factors (modules)

GENIE3 and NMF quantify the importance of genes/motifs as explained variance.
To infer the "directionality", we perform SVD by incorporating the variance as weight.
GENIE3 is a regression: each gene ~ motifs.
SVD and PCA are for extracting correlation.
Although the two concepts differ, it seems to work for assigning directionality.
We might say that genes/motifs highlighted in both approaches are robustly important.

Compute weight.

```{r}
x = t(coef(res))
x = x %*% diag(1 / colMeans(x))
x = sqrt(x) # convert from var to sd

wGene = x[match(rownames(matnrDEGene), row.names(x)), ]
wGene[is.na(wGene)] = 0
rownames(wGene) = rownames(matnrDEGene)

x = basis(res)
x = x %*% diag(1 / colMeans(x))
x = sqrt(x) # convert from var to sd

wMotif = x[match(rownames(matnrDEMotif), row.names(x)), ]
wMotif[is.na(wMotif)] = 0
rownames(wMotif) = rownames(matnrDEMotif)
```

Weighted SVD.

```{r}
identical(colnames(matnrDEGene), colnames(matnrDEMotif))

XGene = assay(matnrDEGene)
XGene = XGene - rowMeans(XGene)
XGene = XGene / rowSds(XGene)

XMotif = assay(matnrDEMotif)
XMotif = XMotif - rowMeans(XMotif)
XMotif = XMotif / rowSds(XMotif)

set.seed(123)
sXgslist = lapply(
  1:dim(res)[3],
  function (i) {
    irlba::irlba(rbind(XGene * wGene[, i], XMotif * wMotif[, i]))
  })

# For each factor, check if first element is much larger than the remaining.
# If not, the gene set is heterogeneous, which could be OK.
lapply(
  sXgslist,
  function (x) x$d)
```

SVD with cells permuted between motif and genes.
Check if the regulator motifs are correlated with regulatee genes.

```{r}
set.seed(123)
sXgsnull = sapply(
  1:dim(res)[3],
  function (i) { # factor
    print(i)
    sapply(
      1:100,
      function (j) { # permutation trial
        x = irlba::irlba(rbind(XGene * wGene[, i],
                               XMotif[, sample(ncol(XMotif))] * wMotif[, i]))
        data.frame(d1 = x$d[1])
      })
  },
  simplify = "array")

# For each NMF factor, check if first SVD component attains P < 0.05
lapply(
  1:dim(res)[3],
  function (i) {
    mean(as.numeric(sXgsnull[, i]) > sXgslist[[i]]$d[1])
  })
```

This setting is for visualization.
SVD direction for plotting.

```{r}
# hepato
sXgssign = c(1, -1, 1, 1)
# stellate
sXgssign = c(-1, -1, 1, 1)
# endothelial
sXgssign = c(-1, -1, -1)
# myelo
sXgssign = c(1, -1, 1, 1)
# T_NK
sXgssign = c(1, -1, 1)
```

Major Genes/Motifs for each NMF factor.

```{r}
dataplot = do.call(
  rbind,
  lapply(
    1:dim(res)[3],
    function (i) {
      x = (XGene / sqrt(ncol(XGene) - 1)) %*% sXgslist[[i]]$v[, 1]
      x = x[, 1]
      x = sort(x * sXgssign[i])
      x = c(head(x, 5), tail(x, 5))
      dataplot = data.frame(
        order = 1:length(x),
        score = x,
        name = sub("^Gene.", "", names(x)),
        type = "Gene",
        module = paste0("Module ", which(moduleindex == i)))
      
      x = (XMotif / sqrt(ncol(XMotif) - 1)) %*% sXgslist[[i]]$v[, 1]
      x = x[, 1]
      x = sort(x * sXgssign[i])
      x = c(head(x, 5), tail(x, 5))
      dataplot = rbind(
        dataplot,
        data.frame(
          order = 1:length(x),
          score = x,
          name = toupper(sub("^Motif.", "", names(x))),
          type = "Motif",
          module = paste0("Module ", which(moduleindex == i))))
      
      return(dataplot)
    }))

dataplot$type = factor(dataplot$type, levels = c("Motif", "Gene"))
p1 =
  ggplot(data = dataplot,
         aes(x = order,
             y = score)) +
  geom_col() +
  geom_text(aes(label = name, y = -0.03 * sign(score), hjust = -0.5 * sign(score) + 0.5), angle = -90) +
  theme(
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    axis.title.x = element_blank()) +
  labs(y = "Correlation with module expression") +
  facet_grid(rows = vars(module), cols = vars(type))
show(p1)
ggsave(p1,
       filename = paste0("GENIE3.NMF.rank", dim(res)[3], ".", tgtct, ".pdf"),
       width = 5, height = 7)
```

Relative expression level by diets, for each NMF factor.

```{r}
A = proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)]
A = as.factor(A)

dataplot =
  do.call(
    rbind,
    lapply(
      1:dim(res)[3],
      function (i) {
        a0 = lm(
          sXgslist[[i]]$v[, 1] * sqrt(nrow(sXgslist[[i]]$v)) * sXgssign[i] ~
            0 + A)
        x = summary(a0)$coefficients[, 1:2]
        x = as.data.frame(x)
        x$diet = sub("^A", "", rownames(x))
        x$Module = paste0("Module ", which(moduleindex == i))
        return(x)
      }))
p1 =
  ggplot(data = dataplot,
         aes(x = diet,
             y = Estimate)) +
  geom_linerange(
    aes(ymin = Estimate - `Std. Error`,
        ymax = Estimate + `Std. Error`)) +
  geom_col() +
  labs(x = NULL,
       y = "Relative expression level of module") +
  facet_grid(rows = vars(Module))
ggsave(filename = paste0(tgtct, ".modulescore_diet.Gene.pdf"), p1,
       height = 3.5, width = 3)

dataplot =
  do.call(
    rbind,
    lapply(
      1:dim(res)[3],
      function (i) {
        data.frame(
          diet = A,
          expression = sXgslist[[i]]$v[, 1] * sqrt(nrow(sXgslist[[i]]$v)) * sXgssign[i],
          Module = paste0("Module ", which(moduleindex == i)))
      }))
p1 =
  ggplot(data = dataplot,
         aes(x = diet,
             y = expression)) +
  geom_violin() +
  geom_boxplot(width = 0.1, fill = "black", outlier.color = NA) +
  stat_summary(fun = median, geom = "point", fill = "white", shape = 21, size = 1.7) +
  labs(x = NULL,
       y = "Module expression in single cells") +
  facet_grid(rows = vars(Module))
ggsave(filename = paste0(tgtct, ".modulescore_diet.geom_violoin.pdf"), p1,
       height = 3.5, width = 3)
```

# Multiple genes-to-one gene analysis

Include experimental condition as predictor.

```{r}
x = data.frame(
  m154207 = (matnrDEGene$Sample == "m154207"),
  m167203 = (matnrDEGene$Sample == "m167203"),
  m168101 = (matnrDEGene$Sample == "m168101"))
x = t(as.matrix(x) * 1)
```

Gene-gene regulation

```{r}
library(GENIE3)

set.seed(123)
weightMatrix = GENIE3(
  rbind(
    assay(matnrDEGene),
    x),
  targets = rownames(matnrDEGene),
  regulators = c(rownames(matnrDEGene), rownames(x)),
  nCores = 22,
  verbose = TRUE)

# saveRDS(weightMatrix, file = paste0("GENIE3_GeneGene.",  tgtct, ".rds"))
weightMatrix = readRDS(paste0("GENIE3_GeneGene.",  tgtct, ".rds"))
rownames(weightMatrix) = sub("^Gene.", "", rownames(weightMatrix))
colnames(weightMatrix) = sub("^Gene.", "", colnames(weightMatrix))
```

Clean noise.

```{r}
plot(quantile(weightMatrix, seq(0, 1, 0.01)))
plot(quantile(weightMatrix, seq(1 - 1e-3, 1, 1e-5)))
plot(quantile(weightMatrix, seq(1 - 1e-4, 1, 1e-6)))

x = median(colQuantiles(weightMatrix, probs = 0.95))
weightMatrix = weightMatrix - x
weightMatrix[weightMatrix < 0] = 0

plot(sort(rowMeans(weightMatrix)))
```

Find key genes for a target gene set.
Load `gslists` from `9_GSEA.Rmd`.

```{r}
dbname = 'REACTOME'; gsname = 'REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227'
dbname = 'GOBP'; gsname = 'GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829'
dbname = 'KEGG'; gsname = 'KEGG_PPAR_SIGNALING_PATHWAY%%M13088'
dbname = 'H'; gsname = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB%%M5890'
dbname = 'KEGG'; gsname = 'KEGG_APOPTOSIS%%M8492'
dbname = 'GOBP'; gsname = 'GOBP_CELL_MIGRATION%%M40389'
dbname = 'REACTOME'; gsname = 'REACTOME_EXTRACELLULAR_MATRIX_ORGANIZATION%%M610'
dbname = 'GOBP'; gsname = 'GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608'
gs = gslists[[ dbname ]][[ gsname ]]
```

```{r}
data = data.frame(
  genename = rownames(weightMatrix),
  score = rowSums(weightMatrix[, colnames(weightMatrix) %in% gs])
)
data = dplyr::left_join(data,
                        as.data.frame(geneAnnotation$genes),
                        by = c("genename" = "symbol"))
t.test(data$score[data$genename %in% gs], data$score[! data$genename %in% gs])
tail(data[order(data$score), ], 20)
```

The enrichment is weak.
Was `nrow(matnrDEGene)` predictors too many for GENIE3?

# Activity score and co-regulation of a gene set

For a given gene set, the following might be confused but are different:
1. Genes that are differentially expressed among conditions
2. "Core" genes in co-regulation, here defined as co-regulated with other genes in the gene set

## Define gene set

Load `gslists` from `9_GSEA.Rmd`.

```{r}
# hepato
dbname = 'GOBP'; gsname = 'GOBP_STEROID_METABOLIC_PROCESS%%M16758'
dbname = 'REACTOME'; gsname = 'REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227'
dbname = 'GOBP'; gsname = 'GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829'
dbname = 'KEGG'; gsname = 'KEGG_PPAR_SIGNALING_PATHWAY%%M13088' # failed check
dbname = 'KEGG'; gsname = 'KEGG_APOPTOSIS%%M8492'
dbname = 'GOBP'; gsname = 'GOBP_APOPTOTIC_PROCESS%%M34075'
dbname = 'GOBP'; gsname = 'GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608'
dbname = 'WIKIPATHWAYS'; gsname = 'WP_FARNESOID_X_RECEPTOR_PATHWAY%%M39411'

# stellate
dbname = 'GOBP'; gsname = 'GOBP_SEMAPHORIN_PLEXIN_SIGNALING_PATHWAY%%M15378'
dbname = 'REACTOME'; gsname = 'REACTOME_EXTRACELLULAR_MATRIX_ORGANIZATION%%M610' # failed check
dbname = 'GOBP'; gsname = 'GOBP_ACTIN_FILAMENT_BASED_PROCESS%%M9082'

# myelo
dbname = 'REACTOME'; gsname = 'REACTOME_CREATION_OF_C4_AND_C2_ACTIVATORS%%M1078'

# hepato endothelial myelo
dbname = 'H'; gsname = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB%%M5890'
dbname = 'GOBP'; gsname = 'GOBP_RESPONSE_TO_CYTOKINE%%M15783' # myelo failed check
dbname = 'GOBP'; gsname = 'GOBP_ADAPTIVE_IMMUNE_RESPONSE%%M13847' # myelo failed check

# hepato stellate myelo
dbname = 'GOBP'; gsname = 'GOBP_CELL_MIGRATION%%M40389' # stellate failed check

# hepato stellate myelo T_NK
dbname = 'KEGG'; gsname = 'KEGG_TGF_BETA_SIGNALING_PATHWAY%%M2642' # hepato & stellate failed check

# endothelial myelo
dbname = 'WIKIPATHWAYS'; gsname = 'WP_VEGFAVEGFR2_SIGNALING_PATHWAY%%M39729'

gs = gslists[[ dbname ]][[ gsname ]]
```

Zonation genes from literature as a gene set

```{r}
gsname = "ZONATION"
x = read.table(
  # "zonation_hepatocyte_mouse_10.1038_nature21065_TableS3_q001.txt", # too many; PC2 also large
  "zonation_hepatocyte_mouse_10.1038_nature21065_TableS3_q1e-6.txt",
  # "zonation_stellate_mouse_10.1016_j.celrep.2019.10.024_TableS1.txt", # not significant
  # "zonation_endothelial_mouse_10.1038_nbt.4231_TableS5_q02.txt", # not significant
  # "zonation_endothelial_mouse_10.1038_nbt.4231_TableS5_q001.txt", # not significant
  # "zonation_endothelial_mouse_10.1038_nbt.4231_TableS5_q1e-6.txt", # not significant
  header = FALSE)$V1
# Convert to rat gene symbol
attach("~/human/publicrat/homologs/mouse_to_rat_homologs.Rda")
x = mouse_to_rat_homologs$RGD.symbol[
  match(
    tolower(x),
    tolower(mouse_to_rat_homologs$NCBI.gene..formerly.Entrezgene..accession))]
gs = x[(! is.na(x)) & (x != "")]
```

Load STRING protein-protein interaction with gs

```{r}
string = data.table::fread(
  file = "~/human/publicrat/STRING/10116.protein.links.name.txt",
  sep ="\t")
string = string[string$protein1 != string$protein2, ]
string = string[string$protein2 %in% gs, ]
string = string %>%
  # dplyr::filter(combined_score >= 0.4) %>%
  dplyr::select(-c("protein2")) %>%
  dplyr::group_by(protein1) %>%
  dplyr::summarize(ppinteractionwithgs = sum(combined_score))

t.test(string$ppinteractionwithgs[string$protein1 %in% gs], 
       string$ppinteractionwithgs[! string$protein1 %in% gs])
```

## Compute gene set activity score

In the code block below, check if the genes in `gs` are co-regulated, more than randomly chosen genes.
If so, the "average expression" is defined as the gene set activity score, `gsactivity`.
`gsactivity` might or might not be differentially expressed between diet conditions.

Use `matnrDEGene` and `matnrDEMotif`, which should include less noise.
When `gsactivity` is not differentially expressed between diet conditions,
instead use `matnrGene` and `matnrMotif`;
specifically for GOBP_SEMAPHORIN_PLEXIN_SIGNALING_PATHWAY and ZONATION.

```{r}
# For DE genes/motifs
identical(colnames(matnrDEGene), colnames(matnrDEMotif))
A = proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)]

# For all genes/motifs
# identical(colnames(matnrGene), colnames(matnrMotif))
# A = proj6$spdietcombined[match(colnames(matnrGene), proj6$cellNames)]

A = as.factor(A)
```

Make weight by gs.

```{r}
# For DE genes/motifs
wGene = (rownames(matnrDEGene) %in% paste0("Gene.", gs)) * 1
names(wGene) = rownames(matnrDEGene)
wMotif = (rownames(matnrDEMotif) %in% paste0("Motif.", gs)) * 1
names(wMotif) = rownames(matnrDEMotif)

# For all genes/motifs
# wGene = (rownames(matnrGene) %in% paste0("Gene.", gs)) * 1
# names(wGene) = rownames(matnrGene)
# wMotif = (rownames(matnrMotif) %in% paste0("Motif.", gs)) * 1
# names(wMotif) = rownames(matnrMotif)
```

Weighted SVD.

```{r}
# For DE genes/motifs
XGene = assay(matnrDEGene)
XMotif = assay(matnrDEMotif)

# For all genes/motifs
# XGene = assay(matnrGene)
# XMotif = assay(matnrMotif)

XGene = XGene - rowMeans(XGene)
XGene = XGene / rowSds(XGene)
XMotif = XMotif - rowMeans(XMotif)
XMotif = XMotif / rowSds(XMotif)

set.seed(123)
sXgs = irlba::irlba(rbind(XGene * wGene, XMotif * wMotif))

# Check if first element is much larger than the remaining.
# If not, the gene set is heterogeneous, and discarded.
sXgs$d
```

SVD with permuted weight.
Check if the regulator motifs/genes are correlated more than randomly picked motifs/genes.

```{r}
set.seed(123)
sXgsnull = 
  sapply(
    1:10, # 1:100,
    function (j) { # permutation trial
      x = irlba::irlba(rbind(XGene * wGene[sample(length(wGene))],
                             XMotif * wMotif[sample(length(wMotif))]))
      x$d[1]
    })

# Check if first SVD component attains P < 0.05
mean(sXgsnull > sXgs$d[1])
```

Define gene set activity score.

```{r}
sXgssign = 1 # 1 or -1
gsactivity = sXgs$v[, 1] * sqrt(nrow(sXgs$v)) * sXgssign
```

Compare `gsactivity` between diets.

```{r}
a0 = lm(gsactivity ~ 0 + A)
dataplot = summary(a0)$coefficients[, 1:2]
dataplot = as.data.frame(dataplot)
dataplot$diet = sub("^A", "", rownames(dataplot))
p1 =
  ggplot(data = dataplot,
         aes(x = diet,
             y = Estimate)) +
  geom_linerange(
    aes(ymin = Estimate - `Std. Error`,
        ymax = Estimate + `Std. Error`)) +
  geom_col() +
  labs(x = NULL,
       y = "Relative expression level of GS")
ggsave(filename = paste0(tgtct, ".", gsname, ".diet.pdf"), p1,
       height = 3.5, width = 3)

dataplot =
  data.frame(
    diet = A,
    expression = gsactivity)
p1 =
  ggplot(data = dataplot,
         aes(x = diet,
             y = expression)) +
  geom_violin() +
  geom_boxplot(width = 0.1, fill = "black", outlier.color = NA) +
  stat_summary(fun = median, geom = "point", fill = "white", shape = 21, size = 1.7) +
  labs(x = NULL,
       y = "GS expression of single cells")
ggsave(filename = paste0(tgtct, ".", gsname, ".diet.geom_violoin.pdf"), p1,
       height = 1, width = 3)

library(pROC)
for (x in setdiff(A, "sp")) {
  print(x)
  A2level = as.character(A)
  A2level[A2level != "sp" & A2level != x] = NA
  A2level = factor(A2level, levels = c("sp", x))
  print(auc(roc(A2level,  gsactivity)))
}
```

## Core genes as those central in co-regulation and protein-protein interaction

Genes central in co-regulation should have strong correlation with `gsactivity`.

Combine with ppinteractionwithgs
Among genes/motifs with large abs(score), if many have high ppinteractionwithgs, this approach is promising.
If most have low ppinteractionwithgs, this approach is not working.

If a few genes have similar and extreme score, and the genes are clustered on chromosome,
the co-regulation can be an artifact; it can be genuine, but is difficult to prove in snATAC-seq.

```{r}
dataplot = data.frame(
  score = rbind(XGene, XMotif) %*% gsactivity / sqrt(nrow(sXgs$v)) / sqrt(nrow(sXgs$v) - 1),
  name = c(sub("Gene.", "", rownames(XGene)),
           toupper(sub("Motif.", "", rownames(XMotif)))),
  genename = c(sub("Gene.", "", rownames(XGene)),
               sub("Motif.", "", rownames(XMotif)))
)

dataplot$ppinteractionwithgs =
  string$ppinteractionwithgs[
    match(dataplot$genename, string$protein1)]
dataplot$ppinteractionwithgs[
  is.na(dataplot$ppinteractionwithgs)] = 0

dataplot$interact = "Low"
dataplot$interact[
  dataplot$ppinteractionwithgs >
    quantile(dataplot$ppinteractionwithgs, 0.95)] = "High"
dataplot$geneset2 = "Genes not in GS"
dataplot$geneset2[dataplot$genename %in% gs] = "Genes in GS"
sum(dataplot$genename %in% gs)
p1 =
  ggplot(
    data = dataplot,
    aes(x = score,
        y = ppinteractionwithgs)) +
  geom_point(aes(color = interact),
             size = 0.5) +
  scale_x_continuous(breaks = seq(-12, 12, 4)/10) +
  scale_color_manual(values = c("Red", "Blue")) +
  geom_text(data = dataplot[abs(dataplot$score) > 0.3 & # 0.4 if not hepato
                              dataplot$interact == "High", ],
            aes(x = score,
                y = ppinteractionwithgs,
                label = name),
            vjust = 0,
            size = 2) +
  facet_grid(rows = vars(geneset2)) +
  labs(x = "Correlation with GS activity score",
       y = "Total protein-protein interactions with GS",
       title = paste0(gsname, "\n", tgtct))
ggsave(p1, filename = paste0("ppinteractionwithgs.", tgtct, ".", gsname, ".pdf"),
       height = 4, width = 5)
```

## Stabilized regression with gene set activity score as dependent variable

The option `stab_test = "mean_sres_score"` is implemented in
<https://github.com/fumi-github/StabilizedRegression-R>

The predictor variables X are `matnrDEGene`.
The response variable Y is `gsactivity`.
The environments are `proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)]`.
These should be defined above.

```{r}
library(StabilizedRegression)

prescreen_size = round(min(table(
  proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)]
))/2)
```

Try a range of `size_weight`

```{r}
swlist = seq(2, 60, 2)
srlist =
  lapply(
    swlist,
    function (sw) {
      print(sw)
      StabilizedRegression(
        t(assay(matnrDEGene)),
        gsactivity,
        proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)],
        pars = list(B = 1000,
                    # stab_test = "mean_sres",
                    stab_test = "mean_sres_score",
                    alpha_stab = 1, # force to choose Top 10 percent of sets
                    size_weight = seq(1, sw),
                    prescreen_size = prescreen_size),
        verbose = 2,
        seed = 123)
    })
names(srlist) = swlist
```

Under `stab_test = "mean_sres"`,
`pval_stab` is not calibrated (probably due to large sample size),
as seen in `pval_stab_median` being much smaller than 0.5 (plotted below).
Thus, we cannot used alpha_stab = 0.05 as cutoff.
Instead, we use `stab_test = "mean_sres_score"`.

In predmods_stab_pval_stab_mse.pdf,
as `sw` increases,
`predmods_stab_pval_stab` increases (good)
and `predmods_stab_mse` decreases (good).
The change is gradual, and there is no optimal `sw`.

```{r}
dataplot = do.call(
  rbind,
  lapply(
    srlist,
    function (x) {
      data.frame(
        pval_stab_median =
          median(sapply(x$learner_list, function (l) l$scores[1])), # this is median(pval_stab)
        predmods_stab_pval_stab =
          median(sapply(x$learner_list, function (l) l$scores[1])[x$weighting > 0]),
        predmods_stab_mse =
          median(sapply(x$learner_list, function (l) l$scores[2])[x$weighting > 0]),
        variable_importance_pos =
          sum(x$variable_importance > 0)
      )}))
dataplot$sw = as.numeric(rownames(dataplot))

plot(dataplot[, c("sw", "pval_stab_median")])
plot(dataplot[, c("sw", "variable_importance_pos")])

p1 =
  ggplot(
    data = dataplot,
    aes(x = predmods_stab_pval_stab,
        y = predmods_stab_mse)) +
  geom_text(aes(label = sw), size = 2)
ggsave(p1, file = "predmods_stab_pval_stab_mse.pdf", width = 6, height = 6)
```

For each variable pair (among `prescreen_size`),
let's say we want both to be included in 1 set (i.e., the expectation is 1).
The size of a set is randomly chosen from `size_weight = seq(1, sw)`.

Let `p = prescreen_size`.
The probability of a pair being included in a set of size 1 is 1*0/p/(p-1).
The probability of a pair being included in a set of size 2 is 2*1/p/(p-1).
The probability of a pair being included in a set of size 3 is 3*2/p/(p-1).
The probability of a pair being included in a set is (sw^2 - 1)/3/p/(p-1).

N.B.
$f(1) = 1*0$
$f(2) = 1*0 + 2*1$
$f(3) = 1*0 + 2*1 + 3*2$
$f(i) = (i^2 - 1)*i/3$

```{r}
Beachpaironce = function (prescreen_size, sw) {
  round(prescreen_size * (prescreen_size - 1) * 3 / (sw^2 - 1))
}
```

`StabilizedRegression` searches for the best set of predictors.

```{r}
sw = 20
x = StabilizedRegression(
  t(assay(matnrDEGene)),
  gsactivity,
  proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)],
  pars = list(B = Beachpaironce(prescreen_size, sw) * 10,
              # stab_test = "mean_sres",
              stab_test = "mean_sres_score",
              alpha_stab = 1, # force to choose Top 10 percent of sets
              size_weight = seq(1, sw),
              prescreen_size = prescreen_size),
  verbose = 2,
  seed = 123)

dataplot = data.frame(
  score = XGene %*% gsactivity / sqrt(nrow(sXgs$v)) / sqrt(nrow(sXgs$v) - 1),
  name  = rownames(XGene)
)
dataplot$variable_importance =
  x$variable_importance[match(dataplot$name, names(x$variable_importance))]
dataplot$variable_importance_pred =
  x$variable_importance_pred[match(dataplot$name, names(x$variable_importance_pred))]
dataplot$variable_importance_diff =
  x$variable_importance_diff[match(dataplot$name, names(x$variable_importance_diff))]
dataplot$name = sub("^Gene.", "", dataplot$name)
ggplot(data = dataplot,
       aes(x = score,
           y = variable_importance)) +
  geom_point() +
  geom_text(data = dataplot[dataplot$variable_importance != 0, ],
            aes(x = score,
                y = variable_importance_pred,
                label = name),
            vjust = 0,
            size = 4)
```

`SRanalysis` internally repeats `StabilizedRegression` for `num_reps` times,
and computes the stability selection probability for each predictor variable.

```{r}
sw = 20
sr = SRanalysis(
  t(assay(matnrDEGene)),
  gsactivity,
  proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)],
  num_reps = 100,
  pars = list(B = 5000,
              stab_test = "mean_sres_score",
              alpha_stab = 1, # force to choose Top 10 percent of sets
              size_weight = seq(1, sw),
              prescreen_size = prescreen_size),
  verbose = 2,
  seed = 123)

# saveRDS(sr, file = paste0("sr.", tgtct, ".", gsname, ".", sw, ".rds"))
sr = readRDS(paste0("sr.", tgtct, ".", gsname, ".", sw, ".rds"))
```

Inspect result.

```{r}
sr$varnames[sr$results$SR$selection_probs > 0.5]
sr$varnames[sr$results$SRdiff$selection_probs > 0.5]

ggplot(
  data = cbind(as.data.frame(t(assay(matnrDEGene))),
               data.frame(gsactivity = gsactivity,
                          Sample = as.character(matnrDEGene$Sample))),
  aes(
    x = Gene.Il1r1, # HALLMARK_TNFA_SIGNALING_VIA_NFKB%%M5890
    y = gsactivity)) +
  geom_point(size = 0.3) +
  stat_smooth(method = lm) +
  facet_grid(cols = vars(Sample))
```
