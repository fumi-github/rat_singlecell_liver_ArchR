---
title: "GRN"
output: html_notebook
---

# Preprocess

Target cell type

```{r}
tgtct =
  "hepato"
  # "stellate"
  # "endothelial"
  # "myelo"
  # "T_NK"
```

Beforehand,
load `mat` from `7_GeneScoreMatrix.Rmd` and rename to `matGene`.
Load `mat` from `8_MotifMatrix.Rmd` and rename to `matMotif`.

```{r}
identical(colnames(matGene), colnames(matMotif))
```

Since highly correlated genes/motifs could be problematic in downstream analysis,
unify those to a representative.

```{r}
mat = matGene[, which(matGene$Clusters4BTmyelo == tgtct)]
# mat = matMotif[, which(matMotif$Clusters4BTmyelo == tgtct)]

matcor = cor(t(assay(mat)), method = "spearman") # takes an hour for matGene

diag(matcor) = 0
quantile(rowMaxs(abs(matcor)), seq(0, 1, 0.01))
quantile(rowMaxs(abs(matcor)), seq(0.99, 1, 0.001))
matcor[abs(matcor) < 0.9] = 0

# Are there negative correlations?
min(matcor)
matcor = abs(matcor)

# omit unique genes/motifs
index = which(rowSums(matcor) > 0)
identical(index, which(colSums(matcor) > 0))
matcor = matcor[index, index]

library(igraph)
x = as.character()
for (j in 1:ncol(matcor)) {
  connected = matcor[, j]
  connected = connected[connected > 0]
  x = c(x,
        as.character(
          rbind(
            names(connected),
            colnames(matcor)[j])))
}
matcorgraph = graph(edges = x, directed = FALSE)
matcorgraphcomp = igraph::components(matcorgraph, mode = "weak")

redundant = list()
for (i in unique(matcorgraphcomp$membership)) {
  m = names(matcorgraphcomp$membership)[matcorgraphcomp$membership == i]
  m = names(sort(rowSums(matcor[m, ]), decreasing = TRUE))
  # the largest is kept (and stored as name), and the others are redundant
  x = list(m[-1])
  names(x) = m[1]
  redundant = c(redundant, x)
}

# non-redundant
index = which(! rownames(mat) %in% unlist(redundant))
matnr = mat[index, ]

redundantGene = redundant
matnrGene = matnr
rownames(matnrGene) = paste0("Gene.", rownames(matnrGene))
# redundantMotif = redundant
# matnrMotif = matnr
# rownames(matnrMotif) = paste0("Motif.", rownames(matnrMotif))

# saveRDS(redundantGene,  file = paste0("redundantGene.",  tgtct, ".rds"))
# saveRDS(matnrGene,      file = paste0("matnrGene.",      tgtct, ".rds"))
# saveRDS(redundantMotif, file = paste0("redundantMotif.", tgtct, ".rds"))
# saveRDS(matnrMotif,     file = paste0("matnrMotif.",     tgtct, ".rds"))
redundantGene  = readRDS(paste0("redundantGene.",  tgtct, ".rds"))
matnrGene      = readRDS(paste0("matnrGene.",      tgtct, ".rds"))
redundantMotif = readRDS(paste0("redundantMotif.", tgtct, ".rds"))
matnrMotif     = readRDS(paste0("matnrMotif.",     tgtct, ".rds"))
```

Inspect.

```{r}
ggplot(data = data.frame(
  x = assay(matnrGene)["Gene.Abcg1", ],
  y = assay(matnrMotif)["Motif.Stat5b", ],
  s = as.character(matnrGene$Sample)),
  aes(x, y)) +
  geom_point(size = 0.5) +
  facet_grid(cols = vars(s))
```

Filter differentially expressed genes/motifs.
Beforehand,
load `resultcompared` from `7_GeneScoreMatrix.Rmd` and rename to `resultcomparedGene`.
Load `resultcompared` from `8_MotifMatrix.Rmd` and rename to `resultcomparedMotif`.
For robustness, we impose abs(estimate) > log2(1.1), which is arbitrary (especially for Motif).

```{r}
x = resultcomparedGene %>%
  dplyr::filter(abs(estimate) > log2(1.1) & FDR < 0.01 & celltype == tgtct) %>%
  dplyr::distinct(genename) %>%
  dplyr::pull(genename)
matnrDEGene = matnrGene[which(rownames(matnrGene) %in% paste0("Gene.", x)), ]

x = resultcomparedMotif %>%
  dplyr::filter(abs(estimate) > log2(1.1) & FDR < 0.01 & celltype == tgtct) %>%
  dplyr::distinct(genename) %>%
  dplyr::pull(genename)
matnrDEMotif = matnrMotif[which(rownames(matnrMotif) %in% paste0("Motif.", x)), ]
```

# One motif-to-one gene analysis

## Correlation between motifs and genes

```{r}
corMG = cor(
  t(assay(matnrMotif)),
  t(assay(matnrGene)),
  method = "spearman")

cornulldistribution =
  sapply(
    1:100,
    function (i) {
      print(i)
      set.seed(i)
      corMGsim = cor(
        t(assay(matnrMotif))[sample(ncol(matnrMotif)), ],
        t(assay(matnrGene)),
        method = "spearman")
      sapply(0:1000, function (x) { sum(abs(corMGsim) > x/1000) })
    })
max(which(
  rowMeans(cornulldistribution) /
    sapply(0:1000, function (x) { sum(abs(corMG) > x/1000) }) >= 0.01)) / 1000
# FDR<0.01
# hepatocyte >=0.035
# T_NK       >=0.161 (all samples; qn) OLD
mean(sort(
  apply(
    cornulldistribution,
    2,
    function (x) { (max(which(x > 0)) - 1)/1000 }),
  decreasing = TRUE)[5:6])
# globalP=0.05
# hepatocyte 0.062
# T_NK       0.281  (all samples; qn) OLD

# Keep only FDR<0.01
corMGsig = corMG
corMGsig[abs(corMGsig) < 0.035] = 0
```

Filter differentially expressed genes/motifs.

```{r}
all(rownames(matnrDEMotif) %in% rownames(corMGsig))
all(rownames(matnrDEGene)  %in% colnames(corMGsig))
corMGsigsig = corMGsig
corMGsigsig = corMGsigsig[rownames(matnrDEMotif), ]
corMGsigsig = corMGsigsig[, rownames(matnrDEGene)]
plot(quantile(abs(corMGsigsig), seq(0, 1, 0.01)))
```

## SVD of corMGsigsig

For hepato, 7 components look significant.
Component 1 is characterized by Motif.Fos, Motif.Smarcc1, Motif.Bach1.
Other components are not evident.

```{r}
x = svd(corMGsigsig)
plot(x$d)
dataplot =
  as.data.frame(x$u); rownames(dataplot) = rownames(corMGsigsig)
  # as.data.frame(x$v); rownames(dataplot) = colnames(corMGsigsig)
ggplot(data = dataplot,
       aes(x = V1,
           y = V2)) +
  geom_point(size = 0.5)

tail(sort(as.matrix(dataplot)[, 1]), 20)
```

## Graph of corMGsigsig

```{r}
library(igraph)

x = as.character()
for (j in 1:ncol(corMGsigsig)) {
  connected = corMGsigsig[, j]
  connected = connected[abs(connected) > 0]
  if (length(connected) > 0) {
    connected = connected[head(order(abs(connected), decreasing = TRUE), 5)]
    x = c(x,
          as.character(
            rbind(
              names(connected),
              colnames(corMGsigsig)[j])
          ))
  }
}
corMGsigsiggraph = graph(edges = x, directed = TRUE)
corMGsigsiggraphcomp = igraph::components(corMGsigsiggraph, mode = "weak")
corMGsigsiggraphcomp$csize
head(sort(degree(corMGsigsiggraph), decreasing = TRUE))
```

## Detect mediator motifs by conditional analysis; diminished t-statistic

We are interested if the effect of condition (ie diet) on Gene j
is mediated by Motif i.
We want to detect the information flow (causality) "condition -> Motif i -> Gene j".
It doesn't matter whether there is bypass "condition -> Gene j".
We test if the association of Gene j with condition decreases
when conditioned by Motif i.

```{r}
x = matnrDEMotif
y = matnrDEGene
g = x$Sample
g[g %in% c("m154211", "m167108")] = "sp"
x$spdietcombined = g
```

Compute the regression
condition ~ (Motif i) + (Gene j),
and keep the t-statistic for (Gene j).
For a fixed j, which i yields diminished t-statistic?

```{r}
cl = makeCluster(20)
clusterExport(cl, "assay")
clusterExport(cl, "x")
clusterExport(cl, "y")
# TODO CCA with all conditions combined as y
statadjusted =
  do.call(
    rbind,
    lapply(
      c("m154207", "m167203", "m168101"),
      function (s) {
        print(s)
        cond = as.character(x$spdietcombined)
        cond[! cond %in% c(s, "sp")] = NA
        do.call(
          rbind,
          lapply(
            row.names(x),
            function (i) {
              print(i)
              do.call(
                rbind,
                # lapply(
                parLapply(cl = cl,
                  row.names(y),
                  function (j) {
                    a0 = lm(y ~ x,
                            data = list(
                              y = (cond != "sp"),
                              x = cbind(
                                t(assay(y)[j, , drop = FALSE]),
                                t(assay(x)[i, , drop = FALSE]))))
                    data.frame(
                      Motif = i,
                      Gene = j,
                      sample = s,
                      statadjusted = summary(a0)$coefficients[2, "t value"])
                  }))
            }))
      }))
# saveRDS(statadjusted, file = paste0("statadjusted.", tgtct, ".rds"))
statadjusted = readRDS(paste0("statadjusted.", tgtct, ".rds"))
```

Overlay statadjusted with corMGsigsig.
We discard motif-gene pairs where corMGsigsig = 0.

```{r}
s = "m154207"
s = "m167203"
s = "m168101"

library(dplyr)
clusterExport(cl, c("s", "corMGsigsig", "statadjusted",
                    "filter",
                    "select",
                    "slice_min",
                    "arrange",
                    "%>%"))
statadjustededges =
  # sapply(
  parSapply(cl = cl,
    colnames(corMGsigsig),
    function (tgtgene) {
      data =
        statadjusted %>%
        dplyr::filter(Gene == tgtgene) %>%
        dplyr::filter(sample == s) %>%
        dplyr::select(Motif, statadjusted)
      data$corMGsigsig = corMGsigsig[data$Motif, tgtgene]
      data$statadjustedpos =
        data$statadjusted *
        sign(median(data$statadjusted))
      statadjustedposlb =
        2.5 * quantile(data$statadjustedpos, 0.25) +
        (-1.5) * quantile(data$statadjustedpos, 0.75)
      dataupstreamMotif =
        data %>%
        dplyr::filter(statadjustedpos < statadjustedposlb) %>%
        dplyr::filter(statadjustedpos >= 0) %>%
        dplyr::filter(corMGsigsig > sqrt(0.5) * max(data$corMGsigsig) |
                        corMGsigsig < sqrt(0.5) * min(data$corMGsigsig)) %>%
        dplyr::slice_min(statadjustedpos, n = 10) %>%
        dplyr::arrange(statadjustedpos)
      x = rep(0, nrow(corMGsigsig))
      names(x) = row.names(corMGsigsig)
      if (nrow(dataupstreamMotif) > 0) {
        x[dataupstreamMotif$Motif] = 1
      }
      return(x)
    })

plot(log10(sort(rowSums(statadjustededges))))
plot(
  log10(rank(- rowSums(statadjustededges))),
  log10(rowSums(statadjustededges)))
head(sort(rowSums(statadjustededges), decreasing = TRUE), 20)
```

The motifs with higher degrees (ie hubs)
show larger differential expression under diet intervention.
However, the corresponding genes (mRNA) of the motif are not differentially expressed.

```{r}
plotdata = data.frame(
  statadjustededges = rowSums(statadjustededges))
foo = resultcomparedMotif[
  resultcomparedMotif$celltype == tgtct &
    resultcomparedMotif$sample == s, ]
plotdata$resultcomparedMotif =
  foo$statistic[match(sub("^Motif.", "", rownames(plotdata)), foo$genename)]
foo = resultcomparedGene[
  resultcomparedGene$celltype == tgtct &
    resultcomparedGene$sample == s, ]
plotdata$resultcomparedGene =
  foo$statistic[match(sub("^Motif.", "", rownames(plotdata)), foo$genename)]
ggplot(data = plotdata) +
  geom_point(
    aes(x = log1p(statadjustededges),
        y = resultcomparedMotif,
        col = resultcomparedGene)) +
  scale_color_gradient2(low = "blue", mid = "white", high = "red")
```

Clustering of motifs

```{r}
foo = statadjustededges[rowSums(statadjustededges) >= 200, ]
# heatmap(foo)
plot(
  hclust(dist(foo, method = "binary"), method = "average"),
  cex = 0.5)
```

## Detect mediator motifs by conditional analysis; mutual information

We want to detect the information flow (causality) "condition -> Motif i -> Gene j".
It doesn't matter whether there is bypass "condition -> Gene j".
In the language of entropy and mutual information, we detect by
mutual_info(Gene j; Motif i; condition) / entropy(Gene j) > 0.
Remark that
mutual_info(Gene j; Motif i; condition)
= mutual_info(Gene j; Motif i)
+ mutual_info(Gene j; condition)
- mutual_info(Gene j; Motif i, condition)
Instead of entropy and mutual information,
we actually use R2 (explained variance) of linear regression.

```{r}
x = matnrDEMotif
y = matnrDEGene
d = data.frame(
  m154207 = (matnrDEGene$Sample == "m154207"),
  m167203 = (matnrDEGene$Sample == "m167203"),
  m168101 = (matnrDEGene$Sample == "m168101"))
d = t(as.matrix(d) * 1)
```

```{r}
residualnull = rowSums( (assay(y) - rowMeans(assay(y)))^2 )

a1 = lm(t(assay(y)) ~ t(d))
R2diet = 1 - colSums(a1$residuals^2) / residualnull

cl = makeCluster(20)
clusterExport(cl, "assay")
clusterExport(cl, "x")
clusterExport(cl, "y")
clusterExport(cl, "d")
clusterExport(cl, "residualnull")
R2Motif =
  do.call(
    rbind,
    # lapply(
    parLapply(cl = cl,
              row.names(x),
              function (i) {
                a1 = lm(t(assay(y)) ~ assay(x)[i, ])
                1 - colSums(a1$residuals^2) / residualnull
              }))
R2Motifdiet =
  do.call(
    rbind,
    # lapply(
    parLapply(cl = cl,
              row.names(x),
              function (i) {
                print(i)
                a1 = lm(t(assay(y)) ~ cbind(assay(x)[i, ], t(d)))
                1 - colSums(a1$residuals^2) / residualnull
              }))
R2Motifdietmutual =
  R2Motif + matrix(R2diet, nrow = nrow(x), ncol = nrow(y), byrow = TRUE) - R2Motifdiet
R2Motifdietmutual[R2Motifdietmutual < 0] = 0
rownames(R2Motifdietmutual) = rownames(x)
# saveRDS(R2Motifdietmutual, paste0("R2Motifdietmutual.", tgtct, ".rds"))
R2Motifdietmutual = readRDS(paste0("R2Motifdietmutual.", tgtct, ".rds"))
```

```{r}
R2Motifdietmutual = readRDS(paste0("R2Motifdietmutual.", tgtct, ".rds"))
weightMatrix = readRDS(paste0("GENIE3.",  tgtct, ".rds"))
x = min(colQuantiles(weightMatrix, probs = 0.95))
weightMatrix = weightMatrix - x
weightMatrix[weightMatrix < 0] = 0
identical(colnames(R2Motifdietmutual), colnames(weightMatrix))
all(rownames(R2Motifdietmutual) %in%  rownames(weightMatrix))
foo = weightMatrix[rownames(R2Motifdietmutual), ]
plot(rowSums(R2Motifdietmutual), rowSums(foo))
plot(colSums(R2Motifdietmutual), colSums(foo))
```

Clean noise.

```{r}
plot(quantile(R2Motifdietmutual, seq(0, 1, 0.01)))
plot(quantile(R2Motifdietmutual, seq(1 - 1e-3, 1, 1e-5)))
plot(quantile(R2Motifdietmutual, seq(1 - 1e-4, 1, 1e-6)))

# Apparently unnecessary (nmf is not suited for sparse matrix)
# But actually improves GSEA of coef
x = min(colQuantiles(R2Motifdietmutual, probs = 0.95))
R2Motifdietmutual = R2Motifdietmutual - x
R2Motifdietmutual[R2Motifdietmutual < 0] = 0

# NG; take intersection with corMGsigsig
# nmf crashes for sparse matrix
# identical(rownames(R2Motifdietmutual), rownames(corMGsigsig))
# identical(colnames(R2Motifdietmutual), colnames(corMGsigsig))
# R2Motifdietmutual[corMGsigsig == 0] = 0

# plot(sort(rowMeans(R2Motifdietmutual)))
R2Motifdietmutual = R2Motifdietmutual[rowMeans(R2Motifdietmutual) > 0.001, ] # arbitrary

plot(hclust(dist(R2Motifdietmutual)))
```

Nonnegative matrix factorization.
Rank cutoff is not obvious from estim.r.
From GSEA of coef, rank = 4 for hepato

```{r}
library(NMF)

gc()
estim.r = nmf(R2Motifdietmutual,
              rank = 2:6,
              nrun = 30, # 10 30
              seed = 123456,
              .opt = 'vP4') # P5 error
# plot(estim.r)

set.seed(123456)
V.random = randomize(R2Motifdietmutual)
gc()
estim.r.random = nmf(V.random,
                     rank = 2:6,
                     nrun = 30, # 10 30
                     seed = 123456,
                     .opt = 'vP4')
plot(estim.r, estim.r.random)
rm(V.random)

res.nndsvd = nmf(R2Motifdietmutual,
                 rank = 4,
                 seed = 'nndsvd')
gc()
res = nmf(R2Motifdietmutual,
          rank = 4,
          nrun = 100, # 10 100
          seed = 123456,
          .opt = 'vP4')
summary(res.nndsvd, target = R2Motifdietmutual)
summary(res, target = R2Motifdietmutual)
# saveRDS(res, file = paste0("R2Motifdietmutual.NMF.", tgtct, ".rds"))
res = readRDS(paste0("R2Motifdietmutual.NMF.", tgtct, ".rds"))

basismap(res)
# coefmap(res)
```

# Multiple motifs-to-one gene analysis

Include experimental condition as predictor.

```{r}
x = data.frame(
  m154207 = (matnrDEGene$Sample == "m154207"),
  m167203 = (matnrDEGene$Sample == "m167203"),
  m168101 = (matnrDEGene$Sample == "m168101"))
x = t(as.matrix(x) * 1)
```

For each gene, compute "regulatory" motifs.

```{r}
library(GENIE3)

set.seed(123)
weightMatrix = GENIE3(
  rbind(
    assay(matnrDEGene),
    assay(matnrDEMotif),
    x),
  targets = rownames(matnrDEGene),
  regulators = c(rownames(matnrDEMotif), rownames(x)),
  nCores = 22,
  verbose = TRUE)

# saveRDS(weightMatrix, file = paste0("GENIE3.",  tgtct, ".rds"))
weightMatrix = readRDS(paste0("GENIE3.",  tgtct, ".rds"))
```

Clean noise.

```{r}
plot(quantile(weightMatrix, seq(0, 1, 0.01)))
plot(quantile(weightMatrix, seq(1 - 1e-3, 1, 1e-5)))
plot(quantile(weightMatrix, seq(1 - 1e-4, 1, 1e-6)))

x = min(colQuantiles(weightMatrix, probs = 0.95))
weightMatrix = weightMatrix - x
weightMatrix[weightMatrix < 0] = 0

plot(sort(rowMeans(weightMatrix)))
weightMatrix = weightMatrix[rowMeans(weightMatrix) > 1e-4, ] # arbitrary
# stellate:    drops m167203 m168101 
# endothelial: drops m167203
# myelo:       drops m167203 m168101 
# T_NK:        drops all experimental conditions

# zero columns cause error in nmf
weightMatrix = weightMatrix[, colMaxs(weightMatrix) > 0]

plot(hclust(dist(weightMatrix)))
```

Nonnegative matrix factorization

To choose the optimal value of r, first try 1; if not clear try 2.
1. (Hutchins2008) suggested to choose the first value where the RSS curve presents an inflection point, and (Frigyesi2008) considered the value of r after which the decrease in the RSS becomes lower than the decrease of the RSS obtained from random data.
2. (Brunet2004) proposed to take the value of r after which the cophenetic coefficient starts to drop steeply.

```{r}
library(NMF)

gc()
estim.r = nmf(weightMatrix,
              rank = 2:6,
              nrun = 30, # 10 30
              seed = 123456,
              .opt = 'vP4') # P5 error
# plot(estim.r)

set.seed(123456)
V.random = randomize(weightMatrix)
gc()
estim.r.random = nmf(V.random,
                     rank = 2:6,
                     nrun = 30, # 10 30
                     seed = 123456,
                     .opt = 'vP4')
# plot(estim.r, estim.r.random)
rm(V.random)

r = 4 # hepato stellate myelo
r = 3 # endothelial T_NK

# res.nndsvd = nmf(weightMatrix,
#                  rank = r,
#                  seed = 'nndsvd')

gc()
res = nmf(weightMatrix,
          rank = r,
          nrun = 100, # 10 100
          seed = 123456,
          .opt = 'vP4')
summary(res, target = weightMatrix)
# saveRDS(res, file = paste0("GENIE3.NMF.rank", r, ".", tgtct, ".rds"))
res = readRDS(paste0("GENIE3.NMF.rank", r, ".", tgtct, ".rds"))

basismap(res)
# coefmap(res)
summary(basis(res))
summary(t(coefficients(res)))
basis(res)["Motif.Hnf4g", ]
```

In `summary(t(coefficients(res)))`, one factor has large median and 3rd quantile.
Does it correspond to "all of the remaining genes"?
The basis for the  factor includes Motif.Hnf4g.
We set this factor as the last one in moduleindex.
Motif.Hnf4g is up in m154207 (HFD4w) and down in m168101 (washout).  Why??

We set the factor(s) with significant GSEA in the beginning (see below).

```{r}
# hepato
moduleindex = c(4, 2, 1, 3)
# stellate
moduleindex = c(1, 2, 4, 3)
# endothelial
moduleindex = c(1, 3, 2)
# myelo
moduleindex = c(3, 1, 2, 4)
# T_NK
moduleindex = c(1, 2, 3)

topMotiflist = lapply(
  moduleindex,
  function (i) {
    x = sort(basis(res)[, i], decreasing = TRUE)
    x = x[! names(x) %in% grep("^m", names(x), value = TRUE)]
    x = x[x > max(x) / 2]
    return(head(names(x), 5))
  })
topMotif = union(do.call(c, topMotiflist), c())

topGenelist = lapply(
  moduleindex,
  function (i) {
    x = sort(coef(res)[i, ], decreasing = TRUE)
    x = x[x > max(x) / 2]
    return(head(names(x), 5))
  })
topGene = union(do.call(c, topGenelist), c())

weightMatrix = readRDS(paste0("GENIE3.",  tgtct, ".rds"))
x = t(weightMatrix[topMotif, topGene])
rownames(x) = sub("^Gene.", "", rownames(x))
colnames(x) = sub("^Motif.", "", colnames(x))

aC = as.data.frame(basis(res)[topMotif, moduleindex])
names(aC) = paste0("Motif.M", 1:ncol(aC))
aR = as.data.frame(t(coef(res)[moduleindex, topGene]))
names(aR) = paste0("Gene.M", 1:ncol(aR))
NMF::aheatmap(
  x,
  color = c("white", "black"),
  annCol = aC,
  annRow = aR,
  main = tgtct,
  treeheight = 0,
  filename = "NMF.heatmap.pdf", width = 5, height = 5)
```

Gene set enrichment analysis for factors of the genes.
Load `gslists` from `9_GSEA.Rmd`.

```{r}
dbnamegsname = rbind(
  data.frame(dbname = 'GOBP', gsname = 'GOBP_STEROID_METABOLIC_PROCESS%%M16758'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_REGULATION_OF_CHOLESTEROL_BIOSYNTHESIS_BY_SREBP_SREBF%%M27001'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_LIPID_STORAGE%%M15541'),
  # data.frame(dbname = 'REACTOME', gsname = 'REACTOME_CHOLINE_CATABOLISM%%M27619'), # small gene set
  data.frame(dbname = 'KEGG', gsname = 'KEGG_PPAR_SIGNALING_PATHWAY%%M13088'),
  data.frame(dbname = 'H', gsname = 'HALLMARK_XENOBIOTIC_METABOLISM%%M5934'),
  data.frame(dbname = 'H', gsname = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB%%M5890'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_CYTOKINE_PRODUCTION%%M13156'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_RESPONSE_TO_CYTOKINE%%M15783'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_INTERLEUKIN_1_SIGNALING%%M27895'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_INTERLEUKIN_10_SIGNALING%%M27605'),
  data.frame(dbname = 'REACTOME', gsname = 'REACTOME_INFLAMMASOMES%%M1072'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_ADAPTIVE_IMMUNE_RESPONSE%%M13847'),
  data.frame(dbname = 'KEGG', gsname = 'KEGG_APOPTOSIS%%M8492'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_ACTIN_FILAMENT_BASED_PROCESS%%M9082'),
  data.frame(dbname = 'GOBP', gsname = 'GOBP_CELL_MIGRATION%%M40389'),
  data.frame(dbname ="REACTOME", gsname = "REACTOME_EXTRACELLULAR_MATRIX_ORGANIZATION%%M610"), # not significant in whole analysis
  data.frame(dbname = 'GOBP', gsname = 'GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608'))
  
#   data.frame(dbname ="GOBP", gsname = "GOBP_CELLULAR_AMINO_ACID_METABOLIC_PROCESS%%M9857"),
#   data.frame(dbname ="REACTOME", gsname = "REACTOME_METABOLISM_OF_AMINO_ACIDS_AND_DERIVATIVES%%M727")
# )

pvalues =
  t(apply(
    dbnamegsname,
    1,
    function (a) {
      gs = gslists[[ a[1] ]][[ a[2] ]]
      x = as.data.frame(t(coef(res)))
      ings = (rownames(x) %in% paste0("Gene.", gs))
      if (min(sum(ings), sum(! ings)) < 5) {
        return(rep(NA, ncol(x)))
      } else {
        return(sapply(
          1:ncol(x),
          function (i) {
            t.test(x[ings, i], x[! ings, i], alternative = "greater", var.equal = TRUE)$p.value
          }
        ))
      }
    }
  ))
pvalues = pvalues[, moduleindex, drop = FALSE]

dataplot = as.data.frame(pvalues)
names(dataplot) =  paste0("Module ", 1:ncol(dataplot))
dataplot$gsname = factor(dbnamegsname$gsname, levels = dbnamegsname$gsname)
dataplot = tidyr::pivot_longer(dataplot,
                               cols = matches("^Module \\d+", perl = TRUE),
                               names_to = "factor",
                               values_to = "P")
p1 =
  ggplot(dataplot,
         aes(x = gsname,
             y = - log10(P))) +
  geom_bar(stat = "identity",
           aes(fill = (P < 0.05 / nrow(pvalues) / ncol(pvalues)))) +
  scale_fill_manual(values = c("gray50", "black")) +
  guides(fill = "none") +
  facet_grid(rows = vars(factor)) +
  theme(axis.text.x = element_text(angle = 90,
                                   hjust = 1,
                                   vjust = 0.5,
                                   size = rel(0.3))) +
  labs(title = tgtct,
       x = NULL)
ggsave(p1, filename = "modulescore_GSEA.Gene.pdf", width = 3, height = 5)
```

Visualize NMF of VarianceImportance vs differential expression.

```{r}
# Run this for Motif
x = as.data.frame(basis(res))
x = x[, moduleindex, drop = FALSE]
names(x) = paste0("Module ", 1:ncol(x))
x$genename = row.names(x)
x = tidyr::pivot_longer(x,
                        cols = matches("^Module \\d+", perl = TRUE),
                        names_to = "factor",
                        values_to = "score")
x$intop = FALSE
for (i in 1:length(topMotiflist)) {
  x$intop[(x$genename %in% topMotiflist[[i]]) &
            (x$factor == paste0("Module ", i))] = TRUE
}
x$genename = sub("^Motif.", "", x$genename)
dataplot = resultcomparedMotif %>%
  dplyr::filter(celltype == tgtct)

# Run this for Gene
x = as.data.frame(t(coef(res)))
x = x[, moduleindex, drop = FALSE]
names(x) = paste0("Module ", 1:ncol(x))
x$genename = row.names(x)
x = tidyr::pivot_longer(x,
                        cols = matches("^Module \\d+", perl = TRUE),
                        names_to = "factor",
                        values_to = "score")
x$intop = FALSE
for (i in 1:length(topGenelist)) {
  x$intop[(x$genename %in% topGenelist[[i]]) &
            (x$factor == paste0("Module ", i))] = TRUE
}
x$genename = sub("^Gene.", "", x$genename)
dataplot = resultcomparedGene %>%
  dplyr::filter(celltype == tgtct)

dataplot = dplyr::inner_join(dataplot, x, by = "genename")
p1 =
  ggplot(data = dataplot,
         aes(x = statistic,
             y = score)) +
  geom_point(aes(color = intop), size = 0.3) +
  scale_color_manual(values = c("black", "red"), guide = "none") +
  facet_grid(rows = vars(factor),
             cols = vars(sample),
             scales = "free_y") +
  labs(x = "Differential expression by diet [Z statistic]",
       y = "Module score") +
  theme(axis.text.x = element_text(size = rel(0.75)),
        axis.text.y = element_text(size = rel(0.75))) +
  theme(panel.spacing.y = unit(1, "lines"))
ggsave(p1, filename = "modulescore_DE.pdf", width = 3.5, height = 4)
```

Although all components could be associated with diet,
quantify to inspect which component is strongly associated with differential gene expression.

```{r}
library(dplyr)

x = as.data.frame(t(coef(res)))
x = x[, moduleindex, drop = FALSE]
names(x) = paste0("Module ", 1:ncol(x))
x$genename = sub("^Gene.", "", row.names(x))
x = tidyr::pivot_longer(x,
                        cols = matches("^Module \\d+", perl = TRUE),
                        names_to = "factor",
                        values_to = "score")
data = resultcomparedGene %>%
  dplyr::filter(celltype == tgtct)
data = dplyr::inner_join(data, x, by = "genename")

data %>%
  dplyr::group_by(factor, sample) %>%
  dplyr::summarize(
    statpos = summary(lm(statistic^2 ~ score + 0,
                         weights = score^2,
                         subset = statistic > 0))$coefficients[3],
    statneg = summary(lm(statistic^2 ~ score + 0,
                         weights = score^2,
                         subset = statistic < 0))$coefficients[3],
    .groups = "drop")
```

## Stabilized regression

UNDER CONSTRUCTION

Do stably associated motifs `sr$results$SR$selection_probs > 0.9`
tend to be in cis with the gene?
Is StabilizedRegression better than GENIE3?

```{r}
library(StabilizedRegression)
sr.Gene.Abcg1 = SRanalysis(t(assay(matnrDEMotif)), assay(matnrDEGene)["Gene.Abcg1", ], proj6$spdietcombined[match(colnames(matnrDEMotif), proj6$cellNames)], num_reps = 10, pars = list(prescreen_size = 20), cores = 4, verbose = 2, seed = 123)
sr.Gene.Igfbp3 = SRanalysis(t(assay(matnrDEMotif)), assay(matnrDEGene)["Gene.Igfbp3", ], proj6$spdietcombined[match(colnames(matnrDEMotif), proj6$cellNames)], num_reps = 10, pars = list(prescreen_size = 20), cores = 4, verbose = 2, seed = 123)
sr.Gene.Il1r1 = SRanalysis(t(assay(matnrDEMotif)), assay(matnrDEGene)["Gene.Il1r1", ], proj6$spdietcombined[match(colnames(matnrDEMotif), proj6$cellNames)], num_reps = 10, pars = list(prescreen_size = 20), cores = 4, verbose = 2, seed = 123)
sr.Gene.Zfp37 = SRanalysis(t(assay(matnrDEMotif)), assay(matnrDEGene)["Gene.Zfp37", ], proj6$spdietcombined[match(colnames(matnrDEMotif), proj6$cellNames)], num_reps = 10, pars = list(prescreen_size = 20), cores = 4, verbose = 2, seed = 123)
sr$varnames[sr$results$SR$selection_probs > 0.9]
sr$varnames[sr$results$SR$selection_probs < 0.5 & sr$results$SRdiff$selection_probs > 0.9]
saveRDS(sr.Gene.Abcg1, file = paste0("sr.Gene.Abcg1.", tgtct, ".rds"))
```

Run `addMotifAnnotations` in 8_MotifMatrix.Rmd

```{r}
foo = readRDS(proj6@peakAnnotation@listData$Motif$Positions)
x = foo$Fos_104 # stable for Il1r1
x = foo$Bach1_108 # stable for Il1r1
x = foo$Nfkb1_701 # not stable for Il1r1
# Il1r1
x[seqnames(x) == "chr9" & abs(start(x) - 42540359) < 1e4, ]
```

# Multiple genes-to-one gene analysis

Include experimental condition as predictor.

```{r}
x = data.frame(
  m154207 = (matnrDEGene$Sample == "m154207"),
  m167203 = (matnrDEGene$Sample == "m167203"),
  m168101 = (matnrDEGene$Sample == "m168101"))
x = t(as.matrix(x) * 1)
```

Gene-gene regulation

```{r}
library(GENIE3)

set.seed(123)
weightMatrix = GENIE3(
  rbind(
    assay(matnrDEGene),
    x),
  targets = rownames(matnrDEGene),
  regulators = c(rownames(matnrDEGene), rownames(x)),
  nCores = 22,
  verbose = TRUE)

# saveRDS(weightMatrix, file = paste0("GENIE3_GeneGene.",  tgtct, ".rds"))
weightMatrix = readRDS(paste0("GENIE3_GeneGene.",  tgtct, ".rds"))
rownames(weightMatrix) = sub("^Gene.", "", rownames(weightMatrix))
colnames(weightMatrix) = sub("^Gene.", "", colnames(weightMatrix))
```

Clean noise.

```{r}
plot(quantile(weightMatrix, seq(0, 1, 0.01)))
plot(quantile(weightMatrix, seq(1 - 1e-3, 1, 1e-5)))
plot(quantile(weightMatrix, seq(1 - 1e-4, 1, 1e-6)))

x = median(colQuantiles(weightMatrix, probs = 0.95))
weightMatrix = weightMatrix - x
weightMatrix[weightMatrix < 0] = 0

plot(sort(rowMeans(weightMatrix)))
```

Find key genes for a target gene set.
Load `gslists` from `9_GSEA.Rmd`.

```{r}
dbname = 'REACTOME'; gsname = 'REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227'
dbname = 'GOBP'; gsname = 'GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829'
dbname = 'KEGG'; gsname = 'KEGG_PPAR_SIGNALING_PATHWAY%%M13088'
dbname = 'H'; gsname = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB%%M5890'
dbname = 'KEGG'; gsname = 'KEGG_APOPTOSIS%%M8492'
dbname = 'GOBP'; gsname = 'GOBP_CELL_MIGRATION%%M40389'
dbname = 'REACTOME'; gsname = 'REACTOME_EXTRACELLULAR_MATRIX_ORGANIZATION%%M610'
dbname = 'GOBP'; gsname = 'GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608'
gs = gslists[[ dbname ]][[ gsname ]]
```

```{r}
data = data.frame(
  genename = rownames(weightMatrix),
  score = rowSums(weightMatrix[, colnames(weightMatrix) %in% gs])
)
data = dplyr::left_join(data,
                        as.data.frame(geneAnnotation$genes),
                        by = c("genename" = "symbol"))
t.test(data$score[data$genename %in% gs], data$score[! data$genename %in% gs])
tail(data[order(data$score), ], 20)
```

The enrichment is weak.
Was `nrow(matnrDEGene)` predictors too many for GENIE3?

# Multiple genes-to-trait analysis

A gene set represents a trait, for which we want to find key genes.

Load `gslists` from `9_GSEA.Rmd`.

```{r}
dbname = 'REACTOME'; gsname = 'REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227'
dbname = 'GOBP'; gsname = 'GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829'
dbname = 'KEGG'; gsname = 'KEGG_PPAR_SIGNALING_PATHWAY%%M13088'
dbname = 'H'; gsname = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB%%M5890'
dbname = 'KEGG'; gsname = 'KEGG_APOPTOSIS%%M8492'
dbname = 'GOBP'; gsname = 'GOBP_CELL_MIGRATION%%M40389'
dbname = 'REACTOME'; gsname = 'REACTOME_EXTRACELLULAR_MATRIX_ORGANIZATION%%M610'
dbname = 'GOBP'; gsname = 'GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608'
gs = gslists[[ dbname ]][[ gsname ]]
```

The first PC of the target gene set is modeled as the dependent variable `gslevel`.

```{r}
x = assay(matnrDEGene)
x = x[rownames(x) %in% paste0("Gene.", gs), ]
# exclude top gene(s)
# x = x[! rownames(x) %in% paste0("Gene.", c("Hmgcs1")), ]
# x = x[! rownames(x) %in% paste0("Gene.", c("Il1r1")), ]
# x = x[! rownames(x) %in% paste0("Gene.", c("Igfbp3")), ]
x = x - rowMeans(x)
x = x / rowSds(x)
s = svd(x)

# gslevel = s$v[, 1] # pc
gslevel = t(x) %*% sign(s$u[, 1]) # average; equal weight on all genes

plot(s$d)
sum(s$d^2) / s$d[1]^2

# Check batch effect
ggplot(data = as.data.frame(s$v)) +
  geom_violin(
    aes(x = proj6$Sample[match(colnames(x), proj6$cellNames)],
        y = V1)) 
summary(lm(s$v[, 1] ~ 0 + proj6$Sample[match(colnames(x), proj6$cellNames)]))
ggplot(data = as.data.frame(s$v),
       aes(x = V1,
           y = V2)) +
  geom_point() +
  facet_grid(rows = vars(proj6$Sample[match(colnames(x), proj6$cellNames)])) +
  geom_rug()

ggplot(data = as.data.frame(s$u),
       aes(x = V1, y = V2)) +
  geom_text(aes(label = sub("^Gene.", "", rownames(x))))
```

Stabilized regression with genes as independent variables and `gslevel` as dependent variable

```{r}
library(StabilizedRegression)

prescreen_size = round(min(table(
  proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)]
))/2)
```

Try a range of `size_weight`

```{r}
swlist = seq(2, 60, 2)
srlist =
  lapply(
    swlist,
    function (sw) {
      print(sw)
      StabilizedRegression(
        t(assay(matnrDEGene)),
        gslevel,
        proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)],
        pars = list(B = 1000,
                    # stab_test = "mean_sres",
                    stab_test = "mean_sres_score",
                    alpha_stab = 1, # force to choose Top 10 percent of sets
                    size_weight = seq(1, sw),
                    prescreen_size = prescreen_size),
        verbose = 2,
        seed = 123)
    })
names(srlist) = swlist
```

Under `stab_test = "mean_sres"`,
`pval_stab` is not calibrated (probably due to large sample size),
as seen in `pval_stab_median` being much smaller than 0.5 (plotted below).
Thus, we cannot used alpha_stab = 0.05 as cutoff.
Instead, we use `stab_test = "mean_sres_score"`.

In predmods_stab_pval_stab_mse.pdf,
as `sw` increases,
`predmods_stab_pval_stab` increases (good)
and `predmods_stab_mse` decreases (good).
The change is gradual, and there is no optimal `sw`.

```{r}
dataplot = do.call(
  rbind,
  lapply(
    srlist,
    function (x) {
      data.frame(
        pval_stab_median =
          median(sapply(x$learner_list, function (l) l$scores[1])), # this is median(pval_stab)
        predmods_stab_pval_stab =
          median(sapply(x$learner_list, function (l) l$scores[1])[x$weighting > 0]),
        predmods_stab_mse =
          median(sapply(x$learner_list, function (l) l$scores[2])[x$weighting > 0]),
        variable_importance_pos =
          sum(x$variable_importance > 0)
      )}))
dataplot$sw = as.numeric(rownames(dataplot))

plot(dataplot[, c("sw", "pval_stab_median")])
plot(dataplot[, c("sw", "variable_importance_pos")])

p1 =
  ggplot(
    data = dataplot,
    aes(x = predmods_stab_pval_stab,
        y = predmods_stab_mse)) +
  geom_text(aes(label = sw), size = 2)
ggsave(p1, file = "predmods_stab_pval_stab_mse.pdf", width = 6, height = 6)
```

Actual run of stabilized regression

```{r}
sw = round(sum(s$d^2) / s$d[1]^2)
B = 1000
# B = 5000
# B = round(prescreen_size^2 / ((sw+1)/2) / (((sw+1)/2)-1)) # for each variable pair, expect 1 set to include both

sr = SRanalysis(
  t(assay(matnrDEGene)),
  gslevel,
  proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)],
  num_reps = 100,
  pars = list(B = B,
              stab_test = "mean_sres_score",
              alpha_stab = 1, # force to choose Top 10 percent of sets
              size_weight = seq(1, sw),
              prescreen_size = prescreen_size),
  verbose = 2,
  seed = 123)

# saveRDS(sr, file = paste0("sr_pc.", tgtct, ".", gsname, ".", sw, ".rds"))
# saveRDS(sr, file = paste0("sr_average.", tgtct, ".", gsname, ".", sw, ".rds"))
saveRDS(sr, file = paste0("sr_average.", tgtct, ".", gsname, ".", sw, ".", B, ".rds"))
# sr = readRDS(paste0("sr_pc.", tgtct, ".", gsname, ".", sw, ".rds"))
sr = readRDS(paste0("sr_average.", tgtct, ".", gsname, ".", sw, ".rds"))
sr = readRDS(paste0("sr_average.", tgtct, ".", gsname, ".", sw, ".", B, ".rds"))
```

IF NOT WORKING, DELETE.
Prescreen by correlation and stability

```{r}
sr1 = StabilizedRegression(
  t(assay(matnrDEGene)),
  gslevel,
  proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)],
  pars = list(m = 1,
              B = NA,
              stab_test = "mean_sres_score",
              prescreen_size = prescreen_size * 2),
  verbose = 2,
  seed = 123)

sr1result = do.call(
  rbind,
  lapply(
    sr1$learner_list[-1], # omit empty set
    function (l) {
      data.frame(
        pval_stab = l$scores[1],
        pred_score = l$scores[2],
        index = l$S)}))
sr1result$genename = names(sr1$variable_importance)[sr1result$index]

prescreened_genename =
  sr1result$genename[
    sr1result$pval_stab >=
      sort(sr1result$pval_stab, decreasing = TRUE)[prescreen_size]]

# pdf("foo.pdf")
# plot(sr1result[, c("pred_score", "pval_stab")])
# dev.off()
# pdf("goo.pdf")
# plot(sr1result[sr1result$genename %in% prescreened_genename,
#                c("pred_score", "pval_stab")])
# dev.off()

sw = round(sum(s$d^2) / s$d[1]^2)
B = 1000
# B = 5000

sr = SRanalysis(
  t(assay(matnrDEGene))[, prescreened_genename],
  gslevel,
  proj6$spdietcombined[match(colnames(matnrDEGene), proj6$cellNames)],
  num_reps = 100,
  pars = list(B = B,
              stab_test = "mean_sres_score",
              alpha_stab = 1, # force to choose Top 10 percent of sets
              size_weight = seq(1, sw)),
  verbose = 2,
  seed = 123)

# saveRDS(sr, file = paste0("sr_average_prescreen_cor_stab.", tgtct, ".", gsname, ".", sw, ".", B, ".rds"))
sr = readRDS(paste0("sr_average_prescreen_cor_stab.", tgtct, ".", gsname, ".", sw, ".", B, ".rds"))
```

Inspect result

```{r}
sr$varnames[sr$results$SR$selection_probs > 0.5]
sr$varnames[sr$results$SRdiff$selection_probs > 0.5]
ggplot(
  data = cbind(as.data.frame(t(assay(matnrDEGene))),
               data.frame(gslevel = gslevel,
                          Sample = as.character(matnrDEGene$Sample))),
  aes(
    # x = Gene.Hmgcs1, # REACTOME_CHOLESTEROL_BIOSYNTHESIS%%M16227
    # x = Gene.Cyp2a2, # GOBP_FATTY_ACID_METABOLIC_PROCESS%%M17829 suggestive
    # x = Gene.Il1r1, # KEGG_APOPTOSIS%%M8492
    x = Gene.Bcl2l1, # KEGG_APOPTOSIS%%M8492 suggestive
    # x = Gene.Il1r1, # GOBP_CELL_MIGRATION%%M40389 suggestive
    # x = Gene.Ccr5, # GOBP_CELL_MIGRATION%%M40389 nonstable
    # x = Gene.Igfbp3, # GOBP_INSULIN_LIKE_GROWTH_FACTOR_RECEPTOR_SIGNALING_PATHWAY%%M12608
    y = gslevel)) +
  geom_point(size = 0.3) +
  stat_smooth(method = lm) +
  facet_grid(cols = vars(Sample))
```
